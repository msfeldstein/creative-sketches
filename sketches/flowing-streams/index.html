<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flowing Streams</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #0a0a0f; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a0f, 0.008);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 25);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x0a0a0f);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8, 0.4, 0.3
    );
    composer.addPass(bloomPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.minDistance = 10;
    controls.maxDistance = 50;

    // Create flowing stream paths using parametric curves
    function createStreamPath(seed) {
      const points = [];
      const numPoints = 50;
      
      for (let i = 0; i <= numPoints; i++) {
        const t = i / numPoints;
        const angle = t * Math.PI * 4 + seed;
        
        // Create flowing, organic curves
        const x = Math.sin(angle * 0.7) * 8 * (1 - t * 0.3);
        const y = Math.cos(angle * 1.3) * 6 * (1 - t * 0.2) + Math.sin(t * Math.PI * 3) * 2;
        const z = Math.cos(angle * 0.9) * 7 * (1 - t * 0.4);
        
        points.push(new THREE.Vector3(x, y, z));
      }
      
      return points;
    }

    // Create multiple streams
    const NUM_STREAMS = 12;
    const PARTICLES_PER_STREAM = 3000;
    const TRAIL_LENGTH = 8;
    const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;

    const streams = [];

    for (let s = 0; s < NUM_STREAMS; s++) {
      const seed = (s / NUM_STREAMS) * Math.PI * 2;
      const pathPoints = createStreamPath(seed);
      
      // Create geometry for this stream
      const TOTAL_VERTICES = PARTICLES_PER_STREAM * TRAIL_SEGMENTS * 2;
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(TOTAL_VERTICES * 3);
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Per-vertex attributes
      const particleIndices = new Float32Array(TOTAL_VERTICES);
      const trailIndices = new Float32Array(TOTAL_VERTICES);
      const speeds = new Float32Array(TOTAL_VERTICES);
      const phases = new Float32Array(TOTAL_VERTICES);
      const timeOffsets = new Float32Array(TOTAL_VERTICES);
      const colorSeeds = new Float32Array(TOTAL_VERTICES);
      
      let vertexIdx = 0;
      for (let p = 0; p < PARTICLES_PER_STREAM; p++) {
        const speed = 0.15 + Math.random() * 0.1;
        const phase = Math.random() * Math.PI * 2;
        const timeOffset = Math.random() * 20;
        const colorSeed = Math.random();
        
        for (let seg = 0; seg < TRAIL_SEGMENTS; seg++) {
          particleIndices[vertexIdx] = p;
          trailIndices[vertexIdx] = seg;
          speeds[vertexIdx] = speed;
          phases[vertexIdx] = phase;
          timeOffsets[vertexIdx] = timeOffset;
          colorSeeds[vertexIdx] = colorSeed;
          vertexIdx++;
          
          particleIndices[vertexIdx] = p;
          trailIndices[vertexIdx] = seg + 1;
          speeds[vertexIdx] = speed;
          phases[vertexIdx] = phase;
          timeOffsets[vertexIdx] = timeOffset;
          colorSeeds[vertexIdx] = colorSeed;
          vertexIdx++;
        }
      }
      
      geo.setAttribute('particleIndex', new THREE.BufferAttribute(particleIndices, 1));
      geo.setAttribute('trailIndex', new THREE.BufferAttribute(trailIndices, 1));
      geo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
      geo.setAttribute('timeOffset', new THREE.BufferAttribute(timeOffsets, 1));
      geo.setAttribute('colorSeed', new THREE.BufferAttribute(colorSeeds, 1));
      
      // Store path in texture
      const pathTexW = pathPoints.length;
      const pathTexH = 1;
      const pathData = new Float32Array(pathTexW * pathTexH * 4);
      pathPoints.forEach((pt, i) => {
        pathData[i * 4 + 0] = pt.x;
        pathData[i * 4 + 1] = pt.y;
        pathData[i * 4 + 2] = pt.z;
        pathData[i * 4 + 3] = 1.0;
      });
      const pathTex = new THREE.DataTexture(pathData, pathTexW, pathTexH, THREE.RGBAFormat, THREE.FloatType);
      pathTex.needsUpdate = true;
      
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uPathTex: { value: pathTex },
          uPathSize: { value: new THREE.Vector2(pathTexW, pathTexH) },
          uTrailSegments: { value: TRAIL_SEGMENTS },
          uStreamSeed: { value: seed }
        },
        vertexShader: `
          attribute float particleIndex;
          attribute float trailIndex;
          attribute float speed;
          attribute float phase;
          attribute float timeOffset;
          attribute float colorSeed;
          
          uniform float uTime;
          uniform sampler2D uPathTex;
          uniform vec2 uPathSize;
          uniform float uTrailSegments;
          uniform float uStreamSeed;
          
          varying float vAlpha;
          varying float vTrailFade;
          varying float vColorSeed;
          varying float vProgress;
          
          vec4 getPathPoint(float idx) {
            return texture2D(uPathTex, vec2((idx + 0.5) / uPathSize.x, 0.5));
          }
          
          void main() {
            vColorSeed = colorSeed;
            
            float baseTime = uTime * speed + timeOffset;
            float trailOffset = trailIndex * 0.08;
            float time = baseTime - trailOffset;
            
            // Wrap around path
            float pathLength = uPathSize.x - 1.0;
            float t = mod(time, pathLength);
            
            // Find segment
            float segIdx = floor(t);
            float segT = fract(t);
            
            // Catmull-Rom interpolation
            vec4 p0 = getPathPoint(max(0.0, segIdx - 1.0));
            vec4 p1 = getPathPoint(segIdx);
            vec4 p2 = getPathPoint(min(segIdx + 1.0, pathLength));
            vec4 p3 = getPathPoint(min(segIdx + 2.0, pathLength));
            
            float t2 = segT * segT;
            float t3 = t2 * segT;
            vec3 pos = 0.5 * (
              2.0 * p1.xyz +
              (-p0.xyz + p2.xyz) * segT +
              (2.0 * p0.xyz - 5.0 * p1.xyz + 4.0 * p2.xyz - p3.xyz) * t2 +
              (-p0.xyz + 3.0 * p1.xyz - 3.0 * p2.xyz + p3.xyz) * t3
            );
            
            // Add perpendicular drift for width
            vec3 tangent = normalize(p2.xyz - p1.xyz + vec3(0.001));
            vec3 perp = normalize(cross(tangent, vec3(0.0, 1.0, 0.1)));
            
            float drift = sin(phase + uTime * 2.0 + segIdx * 0.5) * 0.3;
            pos += perp * drift;
            
            // Trail fade
            vTrailFade = 1.0 - (trailIndex / uTrailSegments);
            vTrailFade = pow(max(vTrailFade, 0.0), 0.6);
            
            vProgress = t / pathLength;
            
            // Alpha
            float alphaBase = smoothstep(0.0, 0.1, vProgress) * smoothstep(1.0, 0.9, vProgress);
            vAlpha = alphaBase * vTrailFade;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          uniform float uTime;
          
          varying float vAlpha;
          varying float vTrailFade;
          varying float vColorSeed;
          varying float vProgress;
          
          vec3 hueShift(vec3 color, float shift) {
            float angle = shift * 6.28318;
            float s = sin(angle);
            float c = cos(angle);
            vec3 weights = vec3(0.299, 0.587, 0.114);
            float wSum = dot(color, weights);
            vec3 c1 = vec3(wSum);
            vec3 c2 = color - c1;
            return c1 + vec3(
              c2.r * c - (c2.g * 0.328 - c2.b * 0.883) * s,
              c2.g * c + (c2.r * 0.328 + c2.b * 0.557) * s,
              c2.b * c - (c2.r * 0.883 + c2.g * 0.557) * s
            );
          }
          
          void main() {
            // Color palette - cyan to magenta gradient
            vec3 cyan = vec3(0.0, 0.9, 1.0);
            vec3 magenta = vec3(1.0, 0.2, 0.8);
            vec3 blue = vec3(0.3, 0.5, 1.0);
            
            float colorMix = vColorSeed + sin(uTime * 0.3 + vProgress * 10.0) * 0.2;
            vec3 color = mix(cyan, magenta, colorMix);
            color = mix(color, blue, sin(vProgress * 5.0) * 0.5 + 0.5);
            
            // Add shimmer
            float shimmer = sin(uTime * 3.0 + vColorSeed * 20.0 + vProgress * 15.0) * 0.5 + 0.5;
            color += vec3(1.0) * pow(shimmer, 4.0) * 0.3;
            
            // Brightness varies along trail
            color *= 0.7 + vTrailFade * 0.3;
            
            gl_FragColor = vec4(color, vAlpha * 0.2);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const mesh = new THREE.LineSegments(geo, mat);
      mesh.frustumCulled = false;
      scene.add(mesh);
      
      streams.push({ mesh, material: mat });
    }

    // Animation
    function animate(time) {
      const t = time * 0.001;
      
      streams.forEach(stream => {
        stream.material.uniforms.uTime.value = t;
      });
      
      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    
    animate(0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
