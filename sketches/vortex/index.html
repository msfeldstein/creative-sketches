<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vortex</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    canvas { display: block; }
    
    #debugPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 100, 150, 0.3);
      border-radius: 8px;
      padding: 16px;
      color: #fff;
      min-width: 200px;
      display: none;
      z-index: 1000;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }
    #debugPanel.visible { display: block; }
    #debugPanel.dragging { user-select: none; }
    #debugPanel h3 {
      margin: -16px -16px 12px -16px;
      padding: 12px 16px;
      font-size: 14px;
      color: rgba(255, 100, 150, 0.9);
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: grab;
      background: rgba(255, 100, 150, 0.1);
      border-radius: 8px 8px 0 0;
      border-bottom: 1px solid rgba(255, 100, 150, 0.2);
    }
    #debugPanel h3:active { cursor: grabbing; }
    #debugPanel .section {
      margin-bottom: 16px;
    }
    #debugPanel .section-title {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    #debugPanel .slider-label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px 0;
      font-size: 13px;
    }
    #debugPanel .slider-label span {
      display: flex;
      justify-content: space-between;
    }
    #debugPanel .slider-label input[type="range"] {
      width: 100%;
      cursor: pointer;
    }
    .hint {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="debugPanel">
    <h3>Vortex Controls</h3>
    <div class="section">
      <div class="section-title">Torus Shape</div>
      <label class="slider-label">
        <span>Major Radius <span id="majorRadiusValue">4.0</span></span>
        <input type="range" id="sliderMajorRadius" min="2" max="8" step="0.1" value="4">
      </label>
      <label class="slider-label">
        <span>Minor Radius <span id="minorRadiusValue">1.5</span></span>
        <input type="range" id="sliderMinorRadius" min="0.5" max="3" step="0.1" value="1.5">
      </label>
    </div>
    <div class="section">
      <div class="section-title">Motion</div>
      <label class="slider-label">
        <span>Flow Speed <span id="flowSpeedValue">100%</span></span>
        <input type="range" id="sliderFlowSpeed" min="10" max="300" value="100">
      </label>
      <label class="slider-label">
        <span>Rotation Speed <span id="rotationSpeedValue">100%</span></span>
        <input type="range" id="sliderRotationSpeed" min="0" max="300" value="100">
      </label>
    </div>
    <div class="section">
      <div class="section-title">Visual</div>
      <label class="slider-label">
        <span>Bloom Intensity <span id="bloomValue">80%</span></span>
        <input type="range" id="sliderBloom" min="0" max="200" value="80">
      </label>
      <label class="slider-label">
        <span>Trail Length <span id="trailLengthValue">100%</span></span>
        <input type="range" id="sliderTrailLength" min="20" max="200" value="100">
      </label>
      <label class="slider-label">
        <span>Brightness <span id="brightnessValue">100%</span></span>
        <input type="range" id="sliderBrightness" min="20" max="200" value="100">
      </label>
      <label class="slider-label">
        <span>Aberration <span id="aberrationValue">3.0</span></span>
        <input type="range" id="sliderAberration" min="0" max="15" step="0.5" value="3">
      </label>
    </div>
  </div>
  <div class="hint">Press D for controls</div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ===========================================
    // CONFIG
    // ===========================================
    const CONFIG = {
      majorRadius: 4.0,      // R - distance from torus center to tube center
      minorRadius: 1.5,      // r - radius of the tube
      particleCount: 3000,
      trailLength: 24,       // number of points in each trail
      flowSpeed: 1.0,
      rotationSpeed: 1.0,
      bloom: 0.8,
      colorShift: 0,
      brightness: 1.0
    };

    // Setup
    const scene = new THREE.Scene();
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000005);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      CONFIG.bloom, 0.4, 0.2
    );
    composer.addPass(bloomPass);

    // Orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.minDistance = 5;
    controls.maxDistance = 30;

    // ===========================================
    // PARTICLE TRAIL SYSTEM WITH CHROMATIC ABERRATION
    // ===========================================
    
    const PARTICLES = CONFIG.particleCount;
    const TRAIL_LENGTH = CONFIG.trailLength;
    const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;
    const CHANNELS = 3; // R, G, B
    const TOTAL_VERTICES = PARTICLES * TRAIL_SEGMENTS * 2 * CHANNELS;

    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(TOTAL_VERTICES * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Per-vertex attributes
    const particleIds = new Float32Array(TOTAL_VERTICES);
    const trailIndices = new Float32Array(TOTAL_VERTICES);
    const uCoords = new Float32Array(TOTAL_VERTICES);      // position around major circle
    const vCoords = new Float32Array(TOTAL_VERTICES);      // position around minor circle (tube)
    const uSpeeds = new Float32Array(TOTAL_VERTICES);      // speed around major circle
    const vSpeeds = new Float32Array(TOTAL_VERTICES);      // speed around minor circle
    const phases = new Float32Array(TOTAL_VERTICES);       // random phase offset
    const colorSeeds = new Float32Array(TOTAL_VERTICES);   // for color variation
    const channels = new Float32Array(TOTAL_VERTICES);     // 0=R, 1=G, 2=B

    let vertexIdx = 0;

    for (let p = 0; p < PARTICLES; p++) {
      // Random starting position on torus surface
      const u = Math.random() * Math.PI * 2;
      const v = Math.random() * Math.PI * 2;
      
      // Speeds - particles flow around the torus
      const uSpeed = 0.3 + Math.random() * 0.4;
      const vSpeed = (Math.random() - 0.5) * 0.8;
      
      const phase = Math.random() * Math.PI * 2;
      const colorSeed = Math.random();
      
      // Create 3 copies of each trail (one per color channel)
      for (let channel = 0; channel < CHANNELS; channel++) {
        // Create line segments for this particle's trail
        for (let seg = 0; seg < TRAIL_SEGMENTS; seg++) {
          // Start vertex of segment
          particleIds[vertexIdx] = p;
          trailIndices[vertexIdx] = seg;
          uCoords[vertexIdx] = u;
          vCoords[vertexIdx] = v;
          uSpeeds[vertexIdx] = uSpeed;
          vSpeeds[vertexIdx] = vSpeed;
          phases[vertexIdx] = phase;
          colorSeeds[vertexIdx] = colorSeed;
          channels[vertexIdx] = channel;
          vertexIdx++;
          
          // End vertex of segment
          particleIds[vertexIdx] = p;
          trailIndices[vertexIdx] = seg + 1;
          uCoords[vertexIdx] = u;
          vCoords[vertexIdx] = v;
          uSpeeds[vertexIdx] = uSpeed;
          vSpeeds[vertexIdx] = vSpeed;
          phases[vertexIdx] = phase;
          colorSeeds[vertexIdx] = colorSeed;
          channels[vertexIdx] = channel;
          vertexIdx++;
        }
      }
    }

    geo.setAttribute('particleId', new THREE.BufferAttribute(particleIds, 1));
    geo.setAttribute('trailIndex', new THREE.BufferAttribute(trailIndices, 1));
    geo.setAttribute('uCoord', new THREE.BufferAttribute(uCoords, 1));
    geo.setAttribute('vCoord', new THREE.BufferAttribute(vCoords, 1));
    geo.setAttribute('uSpeed', new THREE.BufferAttribute(uSpeeds, 1));
    geo.setAttribute('vSpeed', new THREE.BufferAttribute(vSpeeds, 1));
    geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
    geo.setAttribute('colorSeed', new THREE.BufferAttribute(colorSeeds, 1));
    geo.setAttribute('channel', new THREE.BufferAttribute(channels, 1));

    const trailMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMajorRadius: { value: CONFIG.majorRadius },
        uMinorRadius: { value: CONFIG.minorRadius },
        uTrailSegments: { value: TRAIL_SEGMENTS },
        uFlowSpeed: { value: CONFIG.flowSpeed },
        uBrightness: { value: CONFIG.brightness },
        uTrailScale: { value: 1.0 },
        uAberration: { value: 0.03 }  // Chromatic aberration amount
      },
      vertexShader: `
        attribute float particleId;
        attribute float trailIndex;
        attribute float uCoord;
        attribute float vCoord;
        attribute float uSpeed;
        attribute float vSpeed;
        attribute float phase;
        attribute float colorSeed;
        attribute float channel;
        
        uniform float uTime;
        uniform float uMajorRadius;
        uniform float uMinorRadius;
        uniform float uTrailSegments;
        uniform float uFlowSpeed;
        uniform float uTrailScale;
        uniform float uAberration;
        
        varying float vAlpha;
        varying float vTrailFade;
        varying float vChannel;
        varying float vWrap;
        
        const float PI = 3.14159265359;
        const float TWO_PI = 6.28318530718;
        
        // Torus surface position
        vec3 torusPosition(float u, float v, float R, float r) {
          float cu = cos(u);
          float su = sin(u);
          float cv = cos(v);
          float sv = sin(v);
          
          return vec3(
            (R + r * cv) * cu,
            r * sv,
            (R + r * cv) * su
          );
        }
        
        void main() {
          vChannel = channel;
          
          float time = uTime * uFlowSpeed;
          
          // Trail offset - each point is behind in time
          float trailOffset = trailIndex * 0.08 * uTrailScale;
          float t = time - trailOffset;
          
          // Chromatic aberration offset along U (around the torus)
          // R=-1, G=0, B=+1
          float aberrationOffset = (channel - 1.0) * uAberration;
          
          // Current position on torus (using mod for wrapping)
          float currentU = mod(uCoord + t * uSpeed + aberrationOffset, TWO_PI);
          float currentV = mod(vCoord + t * vSpeed, TWO_PI);
          
          vec3 pos = torusPosition(currentU, currentV, uMajorRadius, uMinorRadius);
          
          // Compute adjacent trail positions to detect wraps by DISTANCE
          float nextT = time - (trailIndex + 1.0) * 0.08 * uTrailScale;
          float nextU = mod(uCoord + nextT * uSpeed + aberrationOffset, TWO_PI);
          float nextV = mod(vCoord + nextT * vSpeed, TWO_PI);
          vec3 nextPos = torusPosition(nextU, nextV, uMajorRadius, uMinorRadius);
          
          // If distance to next trail point is too large, this is a wrap
          float dist = length(pos - nextPos);
          vWrap = dist > 1.0 ? 1.0 : 0.0;
          
          // Trail fade - head is bright, tail fades out
          vTrailFade = 1.0 - (trailIndex / (uTrailSegments + 1.0));
          vTrailFade = pow(max(vTrailFade, 0.0), 0.6);
          
          // Alpha based on trail position
          vAlpha = vTrailFade * 0.8;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uBrightness;
        
        varying float vAlpha;
        varying float vTrailFade;
        varying float vChannel;
        varying float vWrap;
        
        void main() {
          // Hide segments that wrap around
          if (vWrap > 0.5) discard;
          if (vAlpha < 0.01) discard;
          
          // Output only the color channel for this vertex
          // channel 0 = Red, channel 1 = Green, channel 2 = Blue
          vec3 color = vec3(0.0);
          
          // Base intensity with trail fade
          float intensity = (0.7 + vTrailFade * 0.5) * uBrightness;
          
          if (vChannel < 0.5) {
            color = vec3(intensity, 0.0, 0.0);  // Red
          } else if (vChannel < 1.5) {
            color = vec3(0.0, intensity, 0.0);  // Green
          } else {
            color = vec3(0.0, 0.0, intensity);  // Blue
          }
          
          gl_FragColor = vec4(color, vAlpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const trailMesh = new THREE.LineSegments(geo, trailMaterial);
    trailMesh.frustumCulled = false;
    scene.add(trailMesh);

    // ===========================================
    // ANIMATION
    // ===========================================
    
    let rotationSpeedMult = CONFIG.rotationSpeed;

    function animate(time) {
      const t = time * 0.001;
      
      trailMaterial.uniforms.uTime.value = t;
      
      // Slow rotation of the whole scene
      trailMesh.rotation.y = t * 0.1 * rotationSpeedMult;
      trailMesh.rotation.x = Math.sin(t * 0.05) * 0.1 * rotationSpeedMult;
      
      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    
    animate(0);

    // ===========================================
    // RESIZE
    // ===========================================
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // ===========================================
    // DEBUG PANEL
    // ===========================================
    
    const debugPanel = document.getElementById('debugPanel');
    
    // Sliders
    const sliderMajorRadius = document.getElementById('sliderMajorRadius');
    const majorRadiusValue = document.getElementById('majorRadiusValue');
    const sliderMinorRadius = document.getElementById('sliderMinorRadius');
    const minorRadiusValue = document.getElementById('minorRadiusValue');
    const sliderFlowSpeed = document.getElementById('sliderFlowSpeed');
    const flowSpeedValue = document.getElementById('flowSpeedValue');
    const sliderRotationSpeed = document.getElementById('sliderRotationSpeed');
    const rotationSpeedValue = document.getElementById('rotationSpeedValue');
    const sliderBloom = document.getElementById('sliderBloom');
    const bloomValue = document.getElementById('bloomValue');
    const sliderTrailLength = document.getElementById('sliderTrailLength');
    const trailLengthValue = document.getElementById('trailLengthValue');
    const sliderBrightness = document.getElementById('sliderBrightness');
    const brightnessValue = document.getElementById('brightnessValue');
    const sliderAberration = document.getElementById('sliderAberration');
    const aberrationValue = document.getElementById('aberrationValue');
    
    // Toggle debug panel
    window.addEventListener('keydown', (e) => {
      if (e.key === 'd' || e.key === 'D') {
        debugPanel.classList.toggle('visible');
      }
    });
    
    // Make panel draggable
    const panelHeader = debugPanel.querySelector('h3');
    let isDragging = false;
    let dragStartX, dragStartY, panelStartX, panelStartY;
    
    panelHeader.addEventListener('mousedown', (e) => {
      isDragging = true;
      debugPanel.classList.add('dragging');
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      const rect = debugPanel.getBoundingClientRect();
      panelStartX = rect.left;
      panelStartY = rect.top;
      e.preventDefault();
    });
    
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      let newX = panelStartX + dx;
      let newY = panelStartY + dy;
      
      const rect = debugPanel.getBoundingClientRect();
      newX = Math.max(0, Math.min(window.innerWidth - rect.width, newX));
      newY = Math.max(0, Math.min(window.innerHeight - rect.height, newY));
      
      debugPanel.style.left = newX + 'px';
      debugPanel.style.top = newY + 'px';
      debugPanel.style.right = 'auto';
    });
    
    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        debugPanel.classList.remove('dragging');
      }
    });
    
    // Slider handlers
    sliderMajorRadius.addEventListener('input', () => {
      const val = parseFloat(sliderMajorRadius.value);
      trailMaterial.uniforms.uMajorRadius.value = val;
      majorRadiusValue.textContent = val.toFixed(1);
    });
    
    sliderMinorRadius.addEventListener('input', () => {
      const val = parseFloat(sliderMinorRadius.value);
      trailMaterial.uniforms.uMinorRadius.value = val;
      minorRadiusValue.textContent = val.toFixed(1);
    });
    
    sliderFlowSpeed.addEventListener('input', () => {
      trailMaterial.uniforms.uFlowSpeed.value = sliderFlowSpeed.value / 100;
      flowSpeedValue.textContent = sliderFlowSpeed.value + '%';
    });
    
    sliderRotationSpeed.addEventListener('input', () => {
      rotationSpeedMult = sliderRotationSpeed.value / 100;
      rotationSpeedValue.textContent = sliderRotationSpeed.value + '%';
    });
    
    sliderBloom.addEventListener('input', () => {
      bloomPass.strength = sliderBloom.value / 100;
      bloomValue.textContent = sliderBloom.value + '%';
    });
    
    sliderTrailLength.addEventListener('input', () => {
      trailMaterial.uniforms.uTrailScale.value = sliderTrailLength.value / 100;
      trailLengthValue.textContent = sliderTrailLength.value + '%';
    });
    
    sliderBrightness.addEventListener('input', () => {
      trailMaterial.uniforms.uBrightness.value = sliderBrightness.value / 100;
      brightnessValue.textContent = sliderBrightness.value + '%';
    });
    
    sliderAberration.addEventListener('input', () => {
      trailMaterial.uniforms.uAberration.value = sliderAberration.value / 100;
      aberrationValue.textContent = parseFloat(sliderAberration.value).toFixed(1);
    });
  </script>
</body>
</html>
