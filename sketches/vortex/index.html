<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vortex</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { DebugPanel, createHint } from '/lib/debug-panel.js';

    // ===========================================
    // CONFIG
    // ===========================================
    const DEFAULT_CONFIG = {
      majorRadius: 4.0,
      minorRadius: 1.5,
      flowSpeed: 100,
      rotationSpeed: 100,
      bloom: 80,
      trailLength: 100,
      brightness: 100,
      aberration: 3.0
    };

    // Setup
    const scene = new THREE.Scene();
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000005);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      DEFAULT_CONFIG.bloom / 100, 0.4, 0.2
    );
    composer.addPass(bloomPass);

    // Orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.minDistance = 5;
    controls.maxDistance = 30;

    // ===========================================
    // PARTICLE TRAIL SYSTEM WITH CHROMATIC ABERRATION
    // ===========================================
    
    const PARTICLES = 3000;
    const TRAIL_LENGTH = 24;
    const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;
    const CHANNELS = 3; // R, G, B
    const TOTAL_VERTICES = PARTICLES * TRAIL_SEGMENTS * 2 * CHANNELS;

    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(TOTAL_VERTICES * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Per-vertex attributes
    const particleIds = new Float32Array(TOTAL_VERTICES);
    const trailIndices = new Float32Array(TOTAL_VERTICES);
    const uCoords = new Float32Array(TOTAL_VERTICES);
    const vCoords = new Float32Array(TOTAL_VERTICES);
    const uSpeeds = new Float32Array(TOTAL_VERTICES);
    const vSpeeds = new Float32Array(TOTAL_VERTICES);
    const phases = new Float32Array(TOTAL_VERTICES);
    const colorSeeds = new Float32Array(TOTAL_VERTICES);
    const channels = new Float32Array(TOTAL_VERTICES);

    let vertexIdx = 0;

    for (let p = 0; p < PARTICLES; p++) {
      const u = Math.random() * Math.PI * 2;
      const v = Math.random() * Math.PI * 2;
      const uSpeed = 0.3 + Math.random() * 0.4;
      const vSpeed = (Math.random() - 0.5) * 0.8;
      const phase = Math.random() * Math.PI * 2;
      const colorSeed = Math.random();
      
      for (let channel = 0; channel < CHANNELS; channel++) {
        for (let seg = 0; seg < TRAIL_SEGMENTS; seg++) {
          particleIds[vertexIdx] = p;
          trailIndices[vertexIdx] = seg;
          uCoords[vertexIdx] = u;
          vCoords[vertexIdx] = v;
          uSpeeds[vertexIdx] = uSpeed;
          vSpeeds[vertexIdx] = vSpeed;
          phases[vertexIdx] = phase;
          colorSeeds[vertexIdx] = colorSeed;
          channels[vertexIdx] = channel;
          vertexIdx++;
          
          particleIds[vertexIdx] = p;
          trailIndices[vertexIdx] = seg + 1;
          uCoords[vertexIdx] = u;
          vCoords[vertexIdx] = v;
          uSpeeds[vertexIdx] = uSpeed;
          vSpeeds[vertexIdx] = vSpeed;
          phases[vertexIdx] = phase;
          colorSeeds[vertexIdx] = colorSeed;
          channels[vertexIdx] = channel;
          vertexIdx++;
        }
      }
    }

    geo.setAttribute('particleId', new THREE.BufferAttribute(particleIds, 1));
    geo.setAttribute('trailIndex', new THREE.BufferAttribute(trailIndices, 1));
    geo.setAttribute('uCoord', new THREE.BufferAttribute(uCoords, 1));
    geo.setAttribute('vCoord', new THREE.BufferAttribute(vCoords, 1));
    geo.setAttribute('uSpeed', new THREE.BufferAttribute(uSpeeds, 1));
    geo.setAttribute('vSpeed', new THREE.BufferAttribute(vSpeeds, 1));
    geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
    geo.setAttribute('colorSeed', new THREE.BufferAttribute(colorSeeds, 1));
    geo.setAttribute('channel', new THREE.BufferAttribute(channels, 1));

    const trailMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMajorRadius: { value: DEFAULT_CONFIG.majorRadius },
        uMinorRadius: { value: DEFAULT_CONFIG.minorRadius },
        uTrailSegments: { value: TRAIL_SEGMENTS },
        uFlowSpeed: { value: DEFAULT_CONFIG.flowSpeed / 100 },
        uBrightness: { value: DEFAULT_CONFIG.brightness / 100 },
        uTrailScale: { value: DEFAULT_CONFIG.trailLength / 100 },
        uAberration: { value: DEFAULT_CONFIG.aberration / 100 }
      },
      vertexShader: `
        attribute float particleId;
        attribute float trailIndex;
        attribute float uCoord;
        attribute float vCoord;
        attribute float uSpeed;
        attribute float vSpeed;
        attribute float phase;
        attribute float colorSeed;
        attribute float channel;
        
        uniform float uTime;
        uniform float uMajorRadius;
        uniform float uMinorRadius;
        uniform float uTrailSegments;
        uniform float uFlowSpeed;
        uniform float uTrailScale;
        uniform float uAberration;
        
        varying float vAlpha;
        varying float vTrailFade;
        varying float vChannel;
        varying float vWrap;
        
        const float PI = 3.14159265359;
        const float TWO_PI = 6.28318530718;
        
        vec3 torusPosition(float u, float v, float R, float r) {
          float cu = cos(u);
          float su = sin(u);
          float cv = cos(v);
          float sv = sin(v);
          
          return vec3(
            (R + r * cv) * cu,
            r * sv,
            (R + r * cv) * su
          );
        }
        
        void main() {
          vChannel = channel;
          
          float time = uTime * uFlowSpeed;
          float trailOffset = trailIndex * 0.08 * uTrailScale;
          float t = time - trailOffset;
          
          float aberrationOffset = (channel - 1.0) * uAberration;
          
          float currentU = mod(uCoord + t * uSpeed + aberrationOffset, TWO_PI);
          float currentV = mod(vCoord + t * vSpeed, TWO_PI);
          
          vec3 pos = torusPosition(currentU, currentV, uMajorRadius, uMinorRadius);
          
          float nextT = time - (trailIndex + 1.0) * 0.08 * uTrailScale;
          float nextU = mod(uCoord + nextT * uSpeed + aberrationOffset, TWO_PI);
          float nextV = mod(vCoord + nextT * vSpeed, TWO_PI);
          vec3 nextPos = torusPosition(nextU, nextV, uMajorRadius, uMinorRadius);
          
          float dist = length(pos - nextPos);
          vWrap = dist > 1.0 ? 1.0 : 0.0;
          
          vTrailFade = 1.0 - (trailIndex / (uTrailSegments + 1.0));
          vTrailFade = pow(max(vTrailFade, 0.0), 0.6);
          
          vAlpha = vTrailFade * 0.8;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uBrightness;
        
        varying float vAlpha;
        varying float vTrailFade;
        varying float vChannel;
        varying float vWrap;
        
        void main() {
          if (vWrap > 0.5) discard;
          if (vAlpha < 0.01) discard;
          
          vec3 color = vec3(0.0);
          float intensity = (0.7 + vTrailFade * 0.5) * uBrightness;
          
          if (vChannel < 0.5) {
            color = vec3(intensity, 0.0, 0.0);
          } else if (vChannel < 1.5) {
            color = vec3(0.0, intensity, 0.0);
          } else {
            color = vec3(0.0, 0.0, intensity);
          }
          
          gl_FragColor = vec4(color, vAlpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const trailMesh = new THREE.LineSegments(geo, trailMaterial);
    trailMesh.frustumCulled = false;
    scene.add(trailMesh);

    // ===========================================
    // DEBUG PANEL (using unified component)
    // ===========================================
    
    const panel = new DebugPanel({
      title: 'Vortex',
      storageKey: 'vortexSettings',
      schema: {
        majorRadius: { 
          type: 'number', label: 'Major Radius', 
          min: 2, max: 8, step: 0.1, default: DEFAULT_CONFIG.majorRadius,
          group: 'Torus Shape'
        },
        minorRadius: { 
          type: 'number', label: 'Minor Radius', 
          min: 0.5, max: 3, step: 0.1, default: DEFAULT_CONFIG.minorRadius,
          group: 'Torus Shape'
        },
        flowSpeed: { 
          type: 'number', label: 'Flow Speed', 
          min: 10, max: 300, default: DEFAULT_CONFIG.flowSpeed, unit: '%',
          group: 'Motion'
        },
        rotationSpeed: { 
          type: 'number', label: 'Rotation Speed', 
          min: 0, max: 300, default: DEFAULT_CONFIG.rotationSpeed, unit: '%',
          group: 'Motion'
        },
        bloom: { 
          type: 'number', label: 'Bloom Intensity', 
          min: 0, max: 200, default: DEFAULT_CONFIG.bloom, unit: '%',
          group: 'Visual'
        },
        trailLength: { 
          type: 'number', label: 'Trail Length', 
          min: 20, max: 200, default: DEFAULT_CONFIG.trailLength, unit: '%',
          group: 'Visual'
        },
        brightness: { 
          type: 'number', label: 'Brightness', 
          min: 20, max: 200, default: DEFAULT_CONFIG.brightness, unit: '%',
          group: 'Visual'
        },
        aberration: { 
          type: 'number', label: 'Aberration', 
          min: 0, max: 15, step: 0.5, default: DEFAULT_CONFIG.aberration,
          group: 'Visual'
        }
      },
      getConfig: () => panel.getValues(),
      onChange: (name, value) => {
        // Update uniforms/state when controls change
        switch (name) {
          case 'majorRadius':
            trailMaterial.uniforms.uMajorRadius.value = value;
            break;
          case 'minorRadius':
            trailMaterial.uniforms.uMinorRadius.value = value;
            break;
          case 'flowSpeed':
            trailMaterial.uniforms.uFlowSpeed.value = value / 100;
            break;
          case 'bloom':
            bloomPass.strength = value / 100;
            break;
          case 'trailLength':
            trailMaterial.uniforms.uTrailScale.value = value / 100;
            break;
          case 'brightness':
            trailMaterial.uniforms.uBrightness.value = value / 100;
            break;
          case 'aberration':
            trailMaterial.uniforms.uAberration.value = value / 100;
            break;
        }
      }
    });

    // Show hint (auto-hidden in iframe)
    createHint('Press D for controls');

    // ===========================================
    // ANIMATION
    // ===========================================

    function animate(time) {
      const t = time * 0.001;
      
      trailMaterial.uniforms.uTime.value = t;
      
      // Get rotation speed from panel (respects defaults in iframe mode)
      const rotationSpeedMult = panel.get('rotationSpeed', t) / 100;
      trailMesh.rotation.y = t * 0.1 * rotationSpeedMult;
      trailMesh.rotation.x = Math.sin(t * 0.05) * 0.1 * rotationSpeedMult;
      
      controls.update();
      composer.render();
      
      // Update bound control UI
      panel.update(t);
      
      requestAnimationFrame(animate);
    }
    
    animate(0);

    // ===========================================
    // RESIZE
    // ===========================================
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
