<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spectral Flowfield</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    body { overflow: hidden; background: #07070a; }
    canvas { display: block; width: 100vw; height: 100vh; }
    .hud {
      position: fixed;
      left: 16px;
      top: 16px;
      z-index: 10;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: rgba(240, 240, 255, 0.82);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 11px;
      user-select: none;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .hud .title { color: rgba(255, 160, 110, 0.9); margin-bottom: 6px; }
    .hud .hint { color: rgba(240, 240, 255, 0.45); text-transform: none; letter-spacing: 0; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" aria-hidden="true">
    <div class="title">Spectral Flowfield</div>
    <div class="hint">Move mouse • Click to stir • R to reset</div>
  </div>

  <script type="module">
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

    const state = {
      w: 1,
      h: 1,
      dpr: 1,
      t: 0,
      mouseX: 0.5,
      mouseY: 0.5,
      mouseVX: 0,
      mouseVY: 0,
      lastMouseX: 0.5,
      lastMouseY: 0.5,
      stir: 0,
      seed: (Math.random() * 1e9) | 0,
      reduceMotion: window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches ?? false,
      drawStride: 2,
      drawOffset: 0,
      avgCostMs: 0,
      lastTuneAt: 0,
    };

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function hash2(x, y) {
      // Deterministic-ish hash for stable flow at a cell.
      let n = (x * 374761393) ^ (y * 668265263) ^ state.seed;
      n = (n ^ (n >>> 13)) * 1274126177;
      return ((n ^ (n >>> 16)) >>> 0) / 4294967296;
    }
    function smoothstep(t) { return t * t * (3 - 2 * t); }
    function valueNoise2(x, y) {
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const u = smoothstep(xf), v = smoothstep(yf);
      const a = hash2(xi, yi);
      const b = hash2(xi + 1, yi);
      const c = hash2(xi, yi + 1);
      const d = hash2(xi + 1, yi + 1);
      return lerp(lerp(a, b, u), lerp(c, d, u), v);
    }

    function resize() {
      const w = Math.max(1, window.innerWidth | 0);
      const h = Math.max(1, window.innerHeight | 0);
      // Cap DPR lower to keep CPU+memory stable in software-rendered environments.
      const dpr = clamp(window.devicePixelRatio || 1, 1, 1.5);
      state.w = w; state.h = h; state.dpr = dpr;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      initParticles();
    }

    let particles = [];
    function initParticles() {
      const area = state.w * state.h;
      // Keep this sketch stable even without GPU acceleration.
      const base = clamp(Math.floor(area / 11000), 6000, 22000);
      const count = state.reduceMotion ? Math.floor(base * 0.45) : base;
      particles = new Array(count);
      for (let i = 0; i < count; i++) {
        particles[i] = {
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          px: 0,
          py: 0,
          h: Math.random(),
          life: Math.random() * 600 + 60,
        };
        particles[i].px = particles[i].x;
        particles[i].py = particles[i].y;
      }
      // Start with a subtle vignette background.
      ctx.fillStyle = '#07070a';
      ctx.fillRect(0, 0, state.w, state.h);
      state.drawStride = state.reduceMotion ? 3 : 2;
      state.drawOffset = 0;
      state.avgCostMs = 0;
      state.lastTuneAt = performance.now();
    }

    function flowAngle(x, y, t) {
      const s = 0.0022; // spatial frequency
      const q = valueNoise2(x * s + t * 0.07, y * s - t * 0.05);
      const r = valueNoise2(x * s - t * 0.03, y * s + t * 0.06);
      let a = (q * 2 - 1) * Math.PI * 1.6 + (r * 2 - 1) * Math.PI * 0.7;

      // Mouse-driven curl (localized).
      const dx = (x / state.w) - state.mouseX;
      const dy = (y / state.h) - state.mouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const influence = Math.exp(-dist * 10) * (0.35 + state.stir * 1.2);
      a += Math.atan2(dy, dx) + influence * 2.2 * (state.mouseVX * 2 - state.mouseVY);
      return a;
    }

    function colorFor(h) {
      // Soft neon palette with additive trails.
      const a = h * Math.PI * 2;
      const r = 0.55 + 0.45 * Math.cos(a + 0.0);
      const g = 0.55 + 0.45 * Math.cos(a + 2.1);
      const b = 0.55 + 0.45 * Math.cos(a + 4.2);
      const rr = Math.floor(255 * Math.pow(r, 1.2));
      const gg = Math.floor(255 * Math.pow(g, 1.2));
      const bb = Math.floor(255 * Math.pow(b, 1.2));
      return `rgb(${rr},${gg},${bb})`;
    }

    function step(dt) {
      const t0 = performance.now();
      state.t += dt;

      // Gentle persistence/fade.
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(7,7,10,0.08)';
      ctx.fillRect(0, 0, state.w, state.h);

      // Additive strokes.
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineWidth = 1;
      ctx.lineCap = 'round';

      const speed = state.reduceMotion ? 0.9 : 1.35;
      const jitter = state.reduceMotion ? 0.05 : 0.12;

      const stride = state.drawStride;
      // Rotate which subset is updated/drawn each frame for stability.
      const startIdx = (state.drawOffset % stride + stride) % stride;
      state.drawOffset = (state.drawOffset + 1) % stride;

      for (let i = startIdx; i < particles.length; i += stride) {
        const p = particles[i];
        p.px = p.x; p.py = p.y;
        const a = flowAngle(p.x, p.y, state.t);
        const vx = Math.cos(a);
        const vy = Math.sin(a);
        p.x += vx * speed + (Math.random() - 0.5) * jitter;
        p.y += vy * speed + (Math.random() - 0.5) * jitter;

        // Wrap.
        if (p.x < 0) p.x += state.w;
        if (p.x >= state.w) p.x -= state.w;
        if (p.y < 0) p.y += state.h;
        if (p.y >= state.h) p.y -= state.h;

        p.life -= 1;
        if (p.life <= 0) {
          p.x = Math.random() * state.w;
          p.y = Math.random() * state.h;
          p.px = p.x; p.py = p.y;
          p.h = Math.random();
          p.life = Math.random() * 700 + 80;
        }

        // Hue slowly drifts with flow.
        p.h = (p.h + 0.0008 + 0.00035 * vx) % 1;
        const alpha = 0.06 + 0.10 * (0.5 + 0.5 * vy);

        ctx.strokeStyle = colorFor(p.h);
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.moveTo(p.px, p.py);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }

      // Reset alpha/composite.
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';

      // Decay stir.
      state.stir *= 0.94;

      // Adaptive quality tuning to avoid renderer crashes in constrained environments.
      const cost = performance.now() - t0;
      state.avgCostMs = state.avgCostMs * 0.9 + cost * 0.1;
      const now = performance.now();
      if (now - state.lastTuneAt > 750) {
        state.lastTuneAt = now;
        if (state.avgCostMs > 20 && state.drawStride < 5) {
          state.drawStride += 1;
          state.drawOffset = 0;
        }
        if (state.avgCostMs > 28 && particles.length > 7000) {
          const nextCount = Math.max(6500, Math.floor(particles.length * 0.85));
          particles = particles.slice(0, nextCount);
        }
        if (state.avgCostMs < 12 && state.drawStride > 1) {
          state.drawStride -= 1;
          state.drawOffset = 0;
        }
      }
    }

    function onPointer(e) {
      const x = e.clientX / state.w;
      const y = e.clientY / state.h;
      const dx = x - state.lastMouseX;
      const dy = y - state.lastMouseY;
      state.mouseX = clamp(x, 0, 1);
      state.mouseY = clamp(y, 0, 1);
      state.mouseVX = lerp(state.mouseVX, dx, 0.35);
      state.mouseVY = lerp(state.mouseVY, dy, 0.35);
      state.lastMouseX = state.mouseX;
      state.lastMouseY = state.mouseY;
    }

    window.addEventListener('pointermove', onPointer, { passive: true });
    window.addEventListener('pointerdown', (e) => {
      onPointer(e);
      state.stir = clamp(state.stir + 1.0, 0, 2.5);
    }, { passive: true });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        state.seed = (Math.random() * 1e9) | 0;
        initParticles();
      }
    });
    window.addEventListener('resize', resize);

    resize();
    let last = performance.now();
    function frame(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      step(dt);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
</body>
</html>
