<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rippling Grid</title>
  <style>
    * { margin: 0; padding: 0; }
    body { 
      overflow: hidden; 
      background: #000008; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <script type="module">
    import { DebugPanel, createHint } from '/lib/debug-panel.js';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Offscreen canvas for zoom blur effect
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    
    // ===========================================
    // CONFIG
    // ===========================================
    const DEFAULT_CONFIG = {
      cellSize: 60,
      speed: 100,
      waveDelay: 22,
      cycleDuration: 250,
      bloom: 186,
      chroma: 235,
      colorShift: 0,
      zoomBlur: 89
    };
    
    // Runtime config (will be updated from panel)
    const CONFIG = {
      cellSize: DEFAULT_CONFIG.cellSize,
      speed: DEFAULT_CONFIG.speed / 100,
      waveDelay: DEFAULT_CONFIG.waveDelay / 100,
      cycleDuration: DEFAULT_CONFIG.cycleDuration / 100,
      bloomIntensity: DEFAULT_CONFIG.bloom / 100,
      chromaticAberration: DEFAULT_CONFIG.chroma / 100,
      colorShift: DEFAULT_CONFIG.colorShift,
      zoomBlur: DEFAULT_CONFIG.zoomBlur / 100
    };
    
    let width, height, cols, rows, centerCol, centerRow, maxDist;
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      offCanvas.width = width;
      offCanvas.height = height;
      
      cols = Math.ceil(width / CONFIG.cellSize) + 2;
      rows = Math.ceil(height / CONFIG.cellSize) + 2;
      
      centerCol = (cols - 1) / 2;
      centerRow = (rows - 1) / 2;
      
      maxDist = Math.sqrt(centerCol * centerCol + centerRow * centerRow);
    }
    
    resize();
    window.addEventListener('resize', resize);
    
    // ===========================================
    // EASING & UTILITIES
    // ===========================================
    function easeInOutSine(t) {
      return -(Math.cos(Math.PI * t) - 1) / 2;
    }
    
    function hash(x, y) {
      let h = x * 374761393 + y * 668265263;
      h = (h ^ (h >> 13)) * 1274126177;
      return (h ^ (h >> 16)) / 4294967296 + 0.5;
    }
    
    // ===========================================
    // COLOR UTILITIES
    // ===========================================
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
    
    function getColor(distFromCenter, normalizedDist, time, channel = 'all') {
      const baseHue = 0.55 + CONFIG.colorShift / 360;
      const hueShift = normalizedDist * 0.15 + Math.sin(time * 0.3) * 0.05;
      let hue = (baseHue + hueShift) % 1;
      
      const chromaOffset = normalizedDist * 0.08 * CONFIG.chromaticAberration;
      if (channel === 'r') hue = (hue + chromaOffset) % 1;
      if (channel === 'b') hue = (hue - chromaOffset + 1) % 1;
      
      const saturation = 0.8 + normalizedDist * 0.2;
      const lightness = 0.5 + (1 - normalizedDist) * 0.2;
      
      return hslToRgb(hue, saturation, lightness);
    }
    
    // ===========================================
    // RENDER SCENE
    // ===========================================
    function renderScene(targetCtx, t) {
      const bgGradient = targetCtx.createRadialGradient(
        width / 2, height / 2, 0,
        width / 2, height / 2, Math.max(width, height) * 0.7
      );
      bgGradient.addColorStop(0, '#0a0a12');
      bgGradient.addColorStop(1, '#000004');
      targetCtx.fillStyle = bgGradient;
      targetCtx.fillRect(0, 0, width, height);
      
      const gridWidth = cols * CONFIG.cellSize;
      const gridHeight = rows * CONFIG.cellSize;
      const offsetX = (width - gridWidth) / 2;
      const offsetY = (height - gridHeight) / 2;
      
      targetCtx.globalCompositeOperation = 'lighter';
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const dx = col - centerCol;
          const dy = row - centerRow;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const normalizedDist = dist / maxDist;
          
          const phase = t / CONFIG.cycleDuration - dist * CONFIG.waveDelay;
          
          const x = offsetX + col * CONFIG.cellSize;
          const y = offsetY + row * CONFIG.cellSize;
          
          renderStrokedCellTo(targetCtx, x, y, CONFIG.cellSize, phase, dist, normalizedDist, t);
        }
      }
      
      targetCtx.globalCompositeOperation = 'source-over';
    }
    
    function renderStrokedCellTo(targetCtx, x, y, size, phase, distFromCenter, normalizedDist, time) {
      const centerX = x + size / 2;
      const centerY = y + size / 2;
      
      const maxRadius = size * 0.48;
      const chromaOffset = normalizedDist * 6 * CONFIG.chromaticAberration;
      
      const mainWaveValue = Math.sin(phase * Math.PI * 2);
      const normalizedMainWave = mainWaveValue * 0.5 + 0.5;
      const fillAmount = Math.pow(Math.max(0, mainWaveValue), 1.5);
      
      const ringCount = 3;
      
      for (let ring = 0; ring < ringCount; ring++) {
        const ringPhase = phase - ring * 0.15;
        const waveValue = Math.sin(ringPhase * Math.PI * 2);
        const radius = maxRadius * (0.3 + (waveValue * 0.5 + 0.5) * 0.7);
        const normalizedWave = waveValue * 0.5 + 0.5;
        const alpha = Math.pow(normalizedWave, 2) * 0.95 + 0.05;
        const baseWidth = 0.5 + (1 - ring / ringCount) * 0.5;
        const lineWidth = baseWidth * (0.6 + alpha * 0.4);
        
        const channels = ['r', 'g', 'b'];
        const offsets = [
          { x: -chromaOffset, y: chromaOffset * 0.5 },
          { x: 0, y: 0 },
          { x: chromaOffset, y: -chromaOffset * 0.5 }
        ];
        
        channels.forEach((channel, i) => {
          const color = getColor(distFromCenter, normalizedDist, time + ring * 0.1, channel);
          const offset = offsets[i];
          
          if (fillAmount < 0.9) {
            targetCtx.beginPath();
            targetCtx.arc(centerX + offset.x, centerY + offset.y, radius, 0, Math.PI * 2);
            targetCtx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.1 * CONFIG.bloomIntensity * (1 - fillAmount)})`;
            targetCtx.lineWidth = lineWidth * 6;
            targetCtx.stroke();
            
            targetCtx.beginPath();
            targetCtx.arc(centerX + offset.x, centerY + offset.y, radius, 0, Math.PI * 2);
            targetCtx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.25 * CONFIG.bloomIntensity * (1 - fillAmount)})`;
            targetCtx.lineWidth = lineWidth * 3;
            targetCtx.stroke();
            
            targetCtx.beginPath();
            targetCtx.arc(centerX + offset.x, centerY + offset.y, radius, 0, Math.PI * 2);
            targetCtx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * (1 - fillAmount)})`;
            targetCtx.lineWidth = lineWidth;
            targetCtx.stroke();
          }
          
          if (fillAmount > 0.1) {
            targetCtx.beginPath();
            targetCtx.arc(centerX + offset.x, centerY + offset.y, radius * 1.2, 0, Math.PI * 2);
            targetCtx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.08 * CONFIG.bloomIntensity * fillAmount})`;
            targetCtx.fill();
            
            targetCtx.beginPath();
            targetCtx.arc(centerX + offset.x, centerY + offset.y, radius * 1.1, 0, Math.PI * 2);
            targetCtx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.15 * CONFIG.bloomIntensity * fillAmount})`;
            targetCtx.fill();
            
            targetCtx.beginPath();
            targetCtx.arc(centerX + offset.x, centerY + offset.y, radius, 0, Math.PI * 2);
            targetCtx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.5 * fillAmount})`;
            targetCtx.fill();
          }
        });
      }
    }
    
    // ===========================================
    // ZOOM BLUR EFFECT
    // ===========================================
    function applyZoomBlur(sourceCanvas, targetCtx, intensity) {
      const cx = width / 2;
      const cy = height / 2;
      const passes = 12;
      
      targetCtx.fillStyle = '#000004';
      targetCtx.fillRect(0, 0, width, height);
      
      for (let i = passes - 1; i >= 0; i--) {
        const t = i / passes;
        const scale = 1 + t * intensity * 0.15;
        const alpha = (1 - t * 0.7) / passes * 2;
        
        targetCtx.save();
        targetCtx.globalAlpha = alpha;
        targetCtx.globalCompositeOperation = 'lighter';
        targetCtx.translate(cx, cy);
        targetCtx.scale(scale, scale);
        targetCtx.translate(-cx, -cy);
        targetCtx.drawImage(sourceCanvas, 0, 0);
        targetCtx.restore();
      }
      
      targetCtx.globalAlpha = 1;
      targetCtx.globalCompositeOperation = 'source-over';
      targetCtx.drawImage(sourceCanvas, 0, 0);
    }
    
    // ===========================================
    // DEBUG PANEL
    // ===========================================
    const panel = new DebugPanel({
      title: 'Rippling Grid',
      storageKey: 'gridCirclesSettings',
      schema: {
        cellSize: {
          type: 'number', label: 'Cell Size',
          min: 40, max: 150, step: 5, default: DEFAULT_CONFIG.cellSize,
          group: 'Grid'
        },
        speed: {
          type: 'number', label: 'Speed',
          min: 20, max: 300, default: DEFAULT_CONFIG.speed, unit: '%',
          group: 'Animation'
        },
        waveDelay: {
          type: 'number', label: 'Wave Delay',
          min: 0, max: 50, default: DEFAULT_CONFIG.waveDelay,
          group: 'Animation'
        },
        cycleDuration: {
          type: 'number', label: 'Cycle Duration',
          min: 50, max: 500, step: 10, default: DEFAULT_CONFIG.cycleDuration,
          group: 'Animation'
        },
        bloom: {
          type: 'number', label: 'Bloom Intensity',
          min: 0, max: 300, default: DEFAULT_CONFIG.bloom, unit: '%',
          group: 'Visual'
        },
        chroma: {
          type: 'number', label: 'Chromatic Aberration',
          min: 0, max: 400, default: DEFAULT_CONFIG.chroma, unit: '%',
          group: 'Visual'
        },
        colorShift: {
          type: 'number', label: 'Color Shift',
          min: 0, max: 360, default: DEFAULT_CONFIG.colorShift, unit: 'Â°',
          group: 'Visual'
        },
        zoomBlur: {
          type: 'number', label: 'Zoom Blur',
          min: 0, max: 100, default: DEFAULT_CONFIG.zoomBlur, unit: '%',
          group: 'Visual'
        }
      },
      getConfig: () => panel.getValues(),
      onChange: (name, value) => {
        switch (name) {
          case 'cellSize':
            CONFIG.cellSize = value;
            resize();
            break;
          case 'speed':
            CONFIG.speed = value / 100;
            break;
          case 'waveDelay':
            CONFIG.waveDelay = value / 100;
            break;
          case 'cycleDuration':
            CONFIG.cycleDuration = value / 100;
            break;
          case 'bloom':
            CONFIG.bloomIntensity = value / 100;
            break;
          case 'chroma':
            CONFIG.chromaticAberration = value / 100;
            break;
          case 'colorShift':
            CONFIG.colorShift = value;
            break;
          case 'zoomBlur':
            CONFIG.zoomBlur = value / 100;
            break;
        }
      }
    });

    createHint('Press D for controls');
    
    // ===========================================
    // MAIN RENDER LOOP
    // ===========================================
    function render(time) {
      const t = time * 0.001 * CONFIG.speed;
      
      if (CONFIG.zoomBlur > 0.01) {
        renderScene(offCtx, t);
        applyZoomBlur(offCanvas, ctx, CONFIG.zoomBlur);
      } else {
        renderScene(ctx, t);
      }
      
      // Vignette
      const vignette = ctx.createRadialGradient(
        width / 2, height / 2, Math.min(width, height) * 0.3,
        width / 2, height / 2, Math.max(width, height) * 0.8
      );
      vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, width, height);
      
      // Film grain
      if (Math.random() > 0.5) {
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.015})`;
        for (let i = 0; i < 50; i++) {
          const gx = Math.random() * width;
          const gy = Math.random() * height;
          ctx.fillRect(gx, gy, 1, 1);
        }
      }
      
      panel.update(t);
      requestAnimationFrame(render);
    }
    
    requestAnimationFrame(render);
  </script>
</body>
</html>
