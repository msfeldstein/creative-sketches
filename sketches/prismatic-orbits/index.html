<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prismatic Orbits</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    body { overflow: hidden; background: radial-gradient(1200px 800px at 50% 40%, #0f0a14 0%, #06060a 55%, #020205 100%); }
    canvas { display: block; width: 100vw; height: 100vh; }
    .hud {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 10;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: rgba(245, 245, 255, 0.8);
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      user-select: none;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .hud .title { color: rgba(160, 220, 255, 0.92); margin-bottom: 6px; }
    .hud .hint { color: rgba(245, 245, 255, 0.45); text-transform: none; letter-spacing: 0; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" aria-hidden="true">
    <div class="title">Prismatic Orbits</div>
    <div class="hint">Drag to orbit • Scroll to zoom • Space to shuffle</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance',
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050508, 0.06);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 120);
    camera.position.set(0, 0.9, 6.5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.rotateSpeed = 0.55;
    controls.zoomSpeed = 0.9;
    controls.minDistance = 3.4;
    controls.maxDistance = 11;
    controls.target.set(0, 0, 0);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.18);
    scene.add(ambient);
    const key = new THREE.DirectionalLight(0xffffff, 1.25);
    key.position.set(3, 4, 2);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0x88aaff, 0.8);
    rim.position.set(-4, 1, -3);
    scene.add(rim);

    // Background star dust
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1600;
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const r = 22 * Math.pow(Math.random(), 0.55);
      const a = Math.random() * Math.PI * 2;
      const b = (Math.random() - 0.5) * Math.PI;
      starPos[i * 3 + 0] = Math.cos(a) * Math.cos(b) * r;
      starPos[i * 3 + 1] = Math.sin(b) * r * 0.65;
      starPos[i * 3 + 2] = Math.sin(a) * Math.cos(b) * r;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({
      color: 0xaab7ff,
      size: 0.02,
      transparent: true,
      opacity: 0.35,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // Central "core" glow sphere.
    const core = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 64, 64),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x8ad0ff,
        emissiveIntensity: 1.5,
        metalness: 0.1,
        roughness: 0.2,
      })
    );
    scene.add(core);

    // Instanced orbit ribbons (torus segments).
    const ringCount = 220;
    const ringGeo = new THREE.TorusGeometry(1, 0.018, 16, 220);
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 0.85,
      roughness: 0.22,
      transparent: true,
      opacity: 0.85,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    const rings = new THREE.InstancedMesh(ringGeo, ringMat, ringCount);
    rings.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(rings);

    const ringColor = new THREE.InstancedBufferAttribute(new Float32Array(ringCount * 3), 3);
    rings.instanceColor = ringColor;

    const tmpMat = new THREE.Matrix4();
    const tmpQ = new THREE.Quaternion();
    const tmpS = new THREE.Vector3();
    const tmpP = new THREE.Vector3();

    const params = { seed: (Math.random() * 1e9) | 0, phase: 0 };
    function rand(i) {
      // Deterministic RNG from seed + i.
      let n = (params.seed ^ (i * 2654435761)) >>> 0;
      n = (n ^ (n >>> 16)) * 2246822507;
      n = (n ^ (n >>> 13)) * 3266489909;
      return ((n ^ (n >>> 16)) >>> 0) / 4294967296;
    }
    function palette(t) {
      // cosine palette
      const a = 0.55, b = 0.45;
      const r = a + b * Math.cos(Math.PI * 2 * (t + 0.00));
      const g = a + b * Math.cos(Math.PI * 2 * (t + 0.33));
      const bb = a + b * Math.cos(Math.PI * 2 * (t + 0.67));
      return [r, g, bb];
    }
    function rebuild() {
      for (let i = 0; i < ringCount; i++) {
        const u = i / (ringCount - 1);
        const radius = 0.55 + 2.0 * Math.pow(rand(i), 1.6);
        const thickness = 0.65 + 1.55 * Math.pow(rand(i + 31), 1.2);

        const ax = (rand(i + 97) * 2 - 1) * Math.PI;
        const ay = (rand(i + 193) * 2 - 1) * Math.PI;
        const az = (rand(i + 307) * 2 - 1) * Math.PI;
        tmpQ.setFromEuler(new THREE.Euler(ax, ay, az));

        tmpP.set(0, (rand(i + 811) * 2 - 1) * 0.12, 0);
        tmpS.set(radius, radius, radius);
        tmpMat.compose(tmpP, tmpQ, tmpS);
        rings.setMatrixAt(i, tmpMat);

        const [cr, cg, cb] = palette((u + rand(i + 509) * 0.22) % 1);
        ringColor.setXYZ(i, cr, cg, cb);

        // Per-instance opacity gradient by scaling the core material a bit.
        // (Actual opacity is global; color intensity gives the gradient feel.)
      }
      ringColor.needsUpdate = true;
      rings.instanceMatrix.needsUpdate = true;
    }
    rebuild();

    // Soft "halo" plane using a small generated canvas texture.
    function makeHaloTexture() {
      const size = 256;
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const g = c.getContext('2d');
      const grad = g.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      grad.addColorStop(0.0, 'rgba(255,255,255,0.95)');
      grad.addColorStop(0.20, 'rgba(170,220,255,0.55)');
      grad.addColorStop(0.55, 'rgba(120,110,255,0.22)');
      grad.addColorStop(1.0, 'rgba(0,0,0,0)');
      g.fillStyle = grad;
      g.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    const halo = new THREE.Mesh(
      new THREE.PlaneGeometry(6.5, 6.5),
      new THREE.MeshBasicMaterial({
        map: makeHaloTexture(),
        transparent: true,
        opacity: 0.35,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      })
    );
    halo.rotation.x = Math.PI * 0.5;
    scene.add(halo);

    function resize() {
      const w = Math.max(1, window.innerWidth | 0);
      const h = Math.max(1, window.innerHeight | 0);
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        params.seed = (Math.random() * 1e9) | 0;
        rebuild();
      }
    });

    const clock = new THREE.Clock();
    function animate() {
      const dt = Math.min(0.05, clock.getDelta());
      params.phase += dt;
      controls.update();

      stars.rotation.y += dt * 0.03;
      stars.rotation.x += dt * 0.01;

      core.rotation.y += dt * 0.7;
      core.rotation.x += dt * 0.4;
      halo.material.opacity = 0.28 + 0.10 * Math.sin(params.phase * 0.9);

      // Ring breathing + slow global precession.
      rings.rotation.y += dt * 0.08;
      rings.rotation.x += dt * 0.03;
      const breathe = 1.0 + 0.04 * Math.sin(params.phase * 1.35);
      rings.scale.setScalar(breathe);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
