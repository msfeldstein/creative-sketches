<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Spirit Tree</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #000003; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    canvas { display: block; }
    
    #debugPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 8px;
      padding: 16px;
      color: #fff;
      min-width: 200px;
      display: none;
      z-index: 1000;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }
    #debugPanel.visible { display: block; }
    #debugPanel.dragging { user-select: none; }
    #debugPanel h3 {
      margin: -16px -16px 12px -16px;
      padding: 12px 16px;
      font-size: 14px;
      color: rgba(100, 200, 255, 0.9);
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: grab;
      background: rgba(100, 200, 255, 0.1);
      border-radius: 8px 8px 0 0;
      border-bottom: 1px solid rgba(100, 200, 255, 0.2);
    }
    #debugPanel h3:active { cursor: grabbing; }
    #debugPanel .section {
      margin-bottom: 16px;
    }
    #debugPanel .section-title {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    #debugPanel button {
      display: block;
      width: 100%;
      padding: 8px 12px;
      margin-bottom: 6px;
      background: rgba(100, 200, 255, 0.15);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 4px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    #debugPanel button:hover {
      background: rgba(100, 200, 255, 0.3);
      border-color: rgba(100, 200, 255, 0.5);
    }
    #debugPanel button:active {
      background: rgba(100, 200, 255, 0.4);
    }
    #debugPanel button.active {
      background: rgba(100, 200, 255, 0.4);
      border-color: rgba(100, 200, 255, 0.7);
    }
    #debugPanel .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      font-size: 13px;
      cursor: pointer;
    }
    #debugPanel .checkbox-label input {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    #debugPanel .slider-label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px 0;
      font-size: 13px;
    }
    #debugPanel .slider-label span {
      display: flex;
      justify-content: space-between;
    }
    #debugPanel .slider-label input[type="range"] {
      width: 100%;
      cursor: pointer;
    }
    .hint {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="debugPanel">
    <h3>Debug Panel</h3>
    <div class="section">
      <button id="btnRegenerate">Regenerate Tree</button>
    </div>
    <div class="section">
      <div class="section-title">Camera Flows</div>
      <button id="btnTopDownZoom">Top Down Zoom</button>
      <button id="btnResetCamera">Reset Camera</button>
    </div>
    <div class="section">
      <div class="section-title">Toggle Effects</div>
      <label class="checkbox-label"><input type="checkbox" id="chkStars" checked> Background Stars</label>
      <label class="slider-label">
        <span>Star Density <span id="starDensityValue">25%</span></span>
        <input type="range" id="sliderStarDensity" min="0" max="100" value="25">
      </label>
      <label class="checkbox-label"><input type="checkbox" id="chkRisingParticles" checked> Rising Sparks</label>
      <label class="checkbox-label"><input type="checkbox" id="chkShootingStars" checked> Shooting Stars</label>
    </div>
    <div class="section">
      <div class="section-title">Visual Controls</div>
      <label class="slider-label">
        <span>Tree Rotation <span id="rotationValue">100%</span></span>
        <input type="range" id="sliderRotation" min="0" max="200" value="100">
      </label>
      <label class="slider-label">
        <span>Bloom Intensity <span id="bloomValue">39%</span></span>
        <input type="range" id="sliderBloom" min="0" max="150" value="39">
      </label>
      <label class="slider-label">
        <span>Particle Speed <span id="speedValue">186%</span></span>
        <input type="range" id="sliderSpeed" min="10" max="300" value="186">
      </label>
      <label class="slider-label">
        <span>Color Shift <span id="colorShiftValue">0°</span></span>
        <input type="range" id="sliderColorShift" min="0" max="360" value="0">
      </label>
      <label class="slider-label">
        <span>Trail Brightness <span id="trailBrightnessValue">100%</span></span>
        <input type="range" id="sliderTrailBrightness" min="10" max="200" value="100">
      </label>
      <label class="slider-label">
        <span>Branch Sway <span id="undulationValue">50%</span></span>
        <input type="range" id="sliderUndulation" min="0" max="200" value="50">
      </label>
    </div>
    <div class="section">
      <div class="section-title">Moon</div>
      <label class="slider-label">
        <span>Phase <span id="moonPhaseValue">New</span></span>
        <input type="range" id="sliderMoonPhase" min="0" max="100" value="0">
      </label>
      <label class="slider-label">
        <span>Rotation <span id="moonRotationValue">333°</span></span>
        <input type="range" id="sliderMoonRotation" min="0" max="360" value="333">
      </label>
      <label class="slider-label">
        <span>Occlusion <span id="moonOcclusionValue">44%</span></span>
        <input type="range" id="sliderMoonOcclusion" min="30" max="60" value="44">
      </label>
    </div>
    <div class="section">
      <div class="section-title">Dev Tools</div>
      <button id="btnCopyConfig">Copy Config to Clipboard</button>
      <button id="btnReload">Reload Page</button>
      <label class="checkbox-label"><input type="checkbox" id="chkLiveReload"> Live Reload (2s)</label>
    </div>
  </div>
  <div class="hint">Press D for debug panel</div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // ===========================================
    // DEFAULT CONFIG - Edit these values directly
    // ===========================================
    const DEFAULT_CONFIG = {
      starDensity: 25,
      treeRotation: 100,
      bloom: 13,
      particleSpeed: 186,
      colorShift: 0,
      trailBrightness: 100,
      undulation: 50,
      moonPhase: 7,
      moonRotation: 333,
      moonOcclusion: 44,
      showStars: true,
      showRisingSparks: true,
      showShootingStars: true
    };
    // ===========================================

    // Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000008, 0.012);
    
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 35);
    camera.lookAt(0, 12, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000003);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.85;
    document.body.appendChild(renderer.domElement);

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      DEFAULT_CONFIG.bloom / 100, 0.4, 0.3
    );
    composer.addPass(bloomPass);

    // Ethereal post-processing shader
    const etherealShader = {
      uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        varying vec2 vUv;
        
        void main() {
          vec2 center = vUv - 0.5;
          float dist = length(center);
          
          // Subtle breathing distortion
          float wave = sin(uTime * 0.4 + dist * 6.0) * 0.003 * dist;
          vec2 uv = vUv + center * wave;
          
          // Chromatic aberration
          float aberr = dist * dist * 0.012;
          vec4 texR = texture2D(tDiffuse, uv + vec2(aberr, 0.0));
          vec4 texG = texture2D(tDiffuse, uv);
          vec4 texB = texture2D(tDiffuse, uv - vec2(aberr, 0.0));
          vec3 color = vec3(texR.r, texG.g, texB.b);
          
          // Vignette
          float vignette = 1.0 - dot(center * 1.3, center * 1.3);
          vignette = pow(max(vignette, 0.0), 1.5);
          
          // Cool color grade
          color *= vec3(0.92, 0.96, 1.1);
          color *= vignette;
          
          // Subtle grain
          float grain = fract(sin(dot(vUv + uTime * 0.1, vec2(12.9898, 78.233))) * 43758.5453) * 0.025;
          color += grain - 0.0125;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `
    };
    const etherealPass = new ShaderPass(etherealShader);
    composer.addPass(etherealPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.03;
    controls.target.set(0, 10, 0);
    controls.autoRotate = false; // Tree rotates instead of camera
    controls.autoRotateSpeed = 0.15;
    controls.minDistance = 12;
    controls.maxDistance = 60;

    // Starfield
    function createStarfield() {
      const count = 10000; // Many more stars available
      const positions = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const phases = new Float32Array(count);
      
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 80 + Math.random() * 120;
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta) * 0.6 + 15;
        positions[i * 3 + 2] = r * Math.cos(phi);
        sizes[i] = 0.3 + Math.pow(Math.random(), 3) * 2.5;
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uDensity: { value: DEFAULT_CONFIG.starDensity / 100 } },
        vertexShader: `
          attribute float size;
          attribute float phase;
          varying float vAlpha;
          uniform float uTime;
          uniform float uDensity;
          void main() {
            // Use phase to determine if this star is visible based on density
            float threshold = phase / 6.28318; // 0 to 1 based on phase
            if (threshold > uDensity) {
              gl_PointSize = 0.0;
              vAlpha = 0.0;
              gl_Position = vec4(0.0);
              return;
            }
            float twinkle = pow(sin(uTime * 1.5 + phase * 8.0) * 0.5 + 0.5, 2.0);
            vAlpha = 0.2 + twinkle * 0.8;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (1.0 + twinkle * 0.3) * (200.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          void main() {
            if (vAlpha < 0.01) discard;
            float d = length(gl_PointCoord - 0.5);
            float a = 1.0 - smoothstep(0.0, 0.5, d);
            a += exp(-d * 3.0) * 0.5;
            gl_FragColor = vec4(0.7, 0.85, 1.0, a * vAlpha * 0.6);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }
    const stars = createStarfield();
    scene.add(stars);

    // Crescent Moon with chromatic aberration
    function createMoon() {
      const moonGeo = new THREE.PlaneGeometry(1, 1);
      const moonMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uPhase: { value: DEFAULT_CONFIG.moonPhase / 100 },
          uRotation: { value: (DEFAULT_CONFIG.moonRotation / 360) * Math.PI * 2 },
          uOcclusion: { value: DEFAULT_CONFIG.moonOcclusion / 100 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float uTime;
          uniform float uPhase;
          uniform float uRotation;
          uniform float uOcclusion;
          varying vec2 vUv;
          
          vec2 rotate2D(vec2 v, float angle) {
            float s = sin(angle);
            float c = cos(angle);
            return vec2(v.x * c - v.y * s, v.x * s + v.y * c);
          }
          
          float moonShape(vec2 uv, vec2 offset, float phase, float rotation, float occlusion) {
            vec2 centered = uv - 0.5 + offset;
            // Apply rotation
            centered = rotate2D(centered, rotation);
            
            float mainCircle = length(centered);
            
            // Cut circle offset based on phase
            // phase 0 = new moon (cut circle fully overlaps)
            // phase 1 = full moon (cut circle far away)
            float cutDistance = mix(0.0, 1.2, phase);
            vec2 cutOffset = centered + vec2(cutDistance, 0.0);
            float cutCircle = length(cutOffset);
            
            // Moon edge
            float moon = smoothstep(0.44, 0.40, mainCircle);
            // Cut away to make crescent - occlusion controls size of cut circle
            moon *= smoothstep(occlusion - 0.03, occlusion + 0.01, cutCircle);
            
            return moon;
          }
          
          void main() {
            // Chromatic aberration offsets
            float aberration = 0.015;
            
            // Sample each color channel with slight offset
            float r = moonShape(vUv, vec2(-aberration, aberration * 0.5), uPhase, uRotation, uOcclusion);
            float g = moonShape(vUv, vec2(0.0, 0.0), uPhase, uRotation, uOcclusion);
            float b = moonShape(vUv, vec2(aberration, -aberration * 0.5), uPhase, uRotation, uOcclusion);
            
            // Combine with slight color tint
            vec3 color = vec3(r * 1.0, g * 0.97, b * 0.92);
            
            // Add subtle glow around the moon
            vec2 centered = vUv - 0.5;
            float dist = length(centered);
            float glow = exp(-dist * 4.0) * 0.12;
            color += vec3(0.6, 0.7, 0.9) * glow;
            
            // Soft edge glow on the crescent
            float edgeGlow = moonShape(vUv, vec2(0.0), uPhase, uRotation, uOcclusion) * 0.25;
            color += vec3(0.8, 0.85, 1.0) * edgeGlow * exp(-dist * 2.0);
            
            float alpha = max(max(r, g), b) + glow * 0.4;
            
            // Subtle shimmer
            float shimmer = sin(uTime * 0.3 + dist * 10.0) * 0.02 + 1.0;
            color *= shimmer;
            
            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      });
      
      const moon = new THREE.Mesh(moonGeo, moonMat);
      // Position in upper right area of sky
      moon.position.set(35, 55, -60);
      moon.scale.set(18, 18, 1);
      // Face the camera roughly
      moon.lookAt(0, 10, 0);
      
      return moon;
    }
    const moon = createMoon();
    scene.add(moon);

    // Create particle texture
    function createParticleTexture() {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      return new THREE.CanvasTexture(canvas);
    }
    const particleTex = createParticleTexture();

    // Generate the magnificent tree
    class Branch {
      constructor(start, end, thickness, depth, parent = null) {
        this.start = start.clone();
        this.end = end.clone();
        this.thickness = thickness;
        this.depth = depth;
        this.parent = parent;
        this.children = [];
      }
    }

    function generateTree() {
      const branches = [];
      
      function grow(start, dir, length, thickness, depth, parent) {
        if (depth > 7 || thickness < 0.02) return null;
        
        const end = start.clone().add(dir.clone().multiplyScalar(length));
        const branch = new Branch(start, end, thickness, depth, parent);
        branches.push(branch);
        if (parent) parent.children.push(branch);
        
        // Branch count varies by depth - more at mid-levels
        let branchCount;
        if (depth === 0) branchCount = 5; // Main branches from trunk
        else if (depth < 3) branchCount = 3 + Math.floor(Math.random() * 2);
        else if (depth < 5) branchCount = 2 + Math.floor(Math.random() * 2);
        else branchCount = 2;
        
        for (let i = 0; i < branchCount; i++) {
          const newDir = dir.clone();
          
          // Spread outward more - tree-like branching
          const spreadAngle = 0.6 + depth * 0.1;
          const azimuth = (i / branchCount) * Math.PI * 2 + Math.random() * 0.5;
          newDir.x += Math.cos(azimuth) * spreadAngle * (0.5 + Math.random() * 0.5);
          newDir.z += Math.sin(azimuth) * spreadAngle * (0.5 + Math.random() * 0.5);
          newDir.y = 0.3 + Math.random() * 0.5; // Less upward at higher branches
          if (depth < 2) newDir.y += 0.3; // Main branches go more up
          newDir.normalize();
          
          const newLength = length * (0.6 + Math.random() * 0.2);
          const newThickness = thickness * (0.55 + Math.random() * 0.15);
          const startT = 0.6 + Math.random() * 0.35;
          const newStart = branch.start.clone().lerp(branch.end, startT);
          
          grow(newStart, newDir, newLength, newThickness, depth + 1, branch);
        }
        
        return branch;
      }
      
      // Main trunk - taller
      const trunkDir = new THREE.Vector3(0, 1, 0);
      trunkDir.x += (Math.random() - 0.5) * 0.03;
      trunkDir.z += (Math.random() - 0.5) * 0.03;
      trunkDir.normalize();
      
      grow(new THREE.Vector3(0, 0, 0), trunkDir, 10, 0.8, 0, null);
      
      // Find all paths from root to tips
      const paths = [];
      function findPaths(branch, path) {
        const newPath = [...path, branch];
        if (branch.children.length === 0) {
          paths.push(newPath);
        } else {
          branch.children.forEach(c => findPaths(c, newPath));
        }
      }
      
      const root = branches[0];
      if (root) findPaths(root, []);
      
      return { branches, paths };
    }

    const tree = generateTree();
    const paths = tree.paths;

    // Create massive particle system for the tree
    const PARTICLES = 20000;
    const MAX_PATH = 10;
    const TRAIL_LENGTH = 6; // Fewer but more visible trail segments

    // Path data texture
    const pathTexW = MAX_PATH;
    const pathTexH = paths.length;
    const pathData = new Float32Array(pathTexW * pathTexH * 4);

    paths.forEach((path, pi) => {
      let idx = 0;
      pathData[(pi * pathTexW + idx) * 4 + 0] = path[0].start.x;
      pathData[(pi * pathTexW + idx) * 4 + 1] = path[0].start.y;
      pathData[(pi * pathTexW + idx) * 4 + 2] = path[0].start.z;
      pathData[(pi * pathTexW + idx) * 4 + 3] = path[0].thickness;
      idx++;
      
      for (let b = 0; b < path.length && idx < MAX_PATH; b++) {
        pathData[(pi * pathTexW + idx) * 4 + 0] = path[b].end.x;
        pathData[(pi * pathTexW + idx) * 4 + 1] = path[b].end.y;
        pathData[(pi * pathTexW + idx) * 4 + 2] = path[b].end.z;
        pathData[(pi * pathTexW + idx) * 4 + 3] = path[b].thickness;
        idx++;
      }
      
      const last = path[path.length - 1];
      while (idx < MAX_PATH) {
        pathData[(pi * pathTexW + idx) * 4 + 0] = last.end.x;
        pathData[(pi * pathTexW + idx) * 4 + 1] = last.end.y;
        pathData[(pi * pathTexW + idx) * 4 + 2] = last.end.z;
        pathData[(pi * pathTexW + idx) * 4 + 3] = last.thickness;
        idx++;
      }
    });

    const pathTex = new THREE.DataTexture(pathData, pathTexW, pathTexH, THREE.RGBAFormat, THREE.FloatType);
    pathTex.needsUpdate = true;

    // Line geometry - non-instanced, each vertex has full particle data
    const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;
    const TOTAL_VERTICES = PARTICLES * TRAIL_SEGMENTS * 2; // 2 vertices per line segment
    
    const geo = new THREE.BufferGeometry();
    // Dummy positions - actual positions computed in shader
    const positions = new Float32Array(TOTAL_VERTICES * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    // Per-vertex attributes
    const pathIndices = new Float32Array(TOTAL_VERTICES);
    const pathLengths = new Float32Array(TOTAL_VERTICES);
    const scales = new Float32Array(TOTAL_VERTICES);
    const speeds = new Float32Array(TOTAL_VERTICES);
    const phases = new Float32Array(TOTAL_VERTICES);
    const timeOffsets = new Float32Array(TOTAL_VERTICES);
    const colorSeeds = new Float32Array(TOTAL_VERTICES);
    const trailIndices = new Float32Array(TOTAL_VERTICES); // The actual trail point index (0 to TRAIL_LENGTH-1)

    // Helper to set vertex data for a line segment
    function setSegmentVertex(vertexIdx, pi, pathLen, scale, speed, phase, timeOffset, colorSeed, trailIdx) {
      pathIndices[vertexIdx] = pi;
      pathLengths[vertexIdx] = pathLen;
      scales[vertexIdx] = scale;
      speeds[vertexIdx] = speed;
      phases[vertexIdx] = phase;
      timeOffsets[vertexIdx] = timeOffset;
      colorSeeds[vertexIdx] = colorSeed;
      trailIndices[vertexIdx] = trailIdx;
    }
    
    // Create burst groups - particles that spawn together
    const NUM_BURSTS = 150;
    const burstTimeOffsets = [];
    const burstPaths = [];
    const burstSpeeds = [];
    const burstColorSeeds = [];
    
    for (let b = 0; b < NUM_BURSTS; b++) {
      burstTimeOffsets.push(Math.random() * 30);
      burstPaths.push(Math.floor(Math.random() * paths.length));
      burstSpeeds.push(0.025 + Math.random() * 0.03);
      burstColorSeeds.push(Math.random());
    }
    
    const BURST_PARTICLES = Math.floor(PARTICLES * 0.7);
    let particleIdx = 0;
    let vertexIdx = 0;
    
    // Create burst particles
    for (let b = 0; b < NUM_BURSTS; b++) {
      const burstSize = 200 + Math.floor(Math.pow(Math.random(), 2) * 600);
      const burstTime = burstTimeOffsets[b];
      const burstPath = burstPaths[b];
      const burstSpeed = burstSpeeds[b];
      const burstColor = burstColorSeeds[b];
      
      for (let p = 0; p < burstSize && particleIdx < BURST_PARTICLES; p++) {
        let pi = burstPath;
        if (Math.random() > 0.3) {
          pi = Math.floor(Math.random() * paths.length);
        }
        
        const baseScale = 0.016 + Math.pow(Math.random(), 2) * 0.028;
        const timeVariation = (Math.random() - 0.5) * 0.8;
        const baseTimeOffset = burstTime + timeVariation;
        const baseSpeed = burstSpeed + (Math.random() - 0.5) * 0.015;
        const basePhase = Math.random() * Math.PI * 2;
        const baseColorSeed = burstColor + (Math.random() - 0.5) * 0.15;
        const pathLen = Math.min(paths[pi].length + 1, MAX_PATH);
        
        // Create line segments for this particle's trail
        for (let seg = 0; seg < TRAIL_SEGMENTS; seg++) {
          // Start vertex of segment (trail point seg)
          setSegmentVertex(vertexIdx++, pi, pathLen, baseScale, baseSpeed, basePhase, baseTimeOffset, baseColorSeed, seg);
          // End vertex of segment (trail point seg+1)
          setSegmentVertex(vertexIdx++, pi, pathLen, baseScale, baseSpeed, basePhase, baseTimeOffset, baseColorSeed, seg + 1);
        }
        particleIdx++;
      }
    }
    
    // Fill remaining with uniform backdrop particles
    for (let i = particleIdx; i < PARTICLES; i++) {
      const pi = Math.floor(Math.random() * paths.length);
      const baseScale = 0.012 + Math.pow(Math.random(), 2) * 0.02;
      const baseSpeed = 0.03 + Math.random() * 0.04;
      const basePhase = Math.random() * Math.PI * 2;
      const baseTimeOffset = Math.random() * 30;
      const baseColorSeed = Math.random();
      const pathLen = Math.min(paths[pi].length + 1, MAX_PATH);
      
      for (let seg = 0; seg < TRAIL_SEGMENTS; seg++) {
        setSegmentVertex(vertexIdx++, pi, pathLen, baseScale, baseSpeed, basePhase, baseTimeOffset, baseColorSeed, seg);
        setSegmentVertex(vertexIdx++, pi, pathLen, baseScale, baseSpeed, basePhase, baseTimeOffset, baseColorSeed, seg + 1);
      }
    }

    geo.setAttribute('pathIndex', new THREE.BufferAttribute(pathIndices, 1));
    geo.setAttribute('pathLength', new THREE.BufferAttribute(pathLengths, 1));
    geo.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
    geo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
    geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
    geo.setAttribute('timeOffset', new THREE.BufferAttribute(timeOffsets, 1));
    geo.setAttribute('colorSeed', new THREE.BufferAttribute(colorSeeds, 1));
    geo.setAttribute('trailIndex', new THREE.BufferAttribute(trailIndices, 1));

    const treeMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uPathTex: { value: pathTex },
        uPathSize: { value: new THREE.Vector2(pathTexW, pathTexH) },
        uTrailSegments: { value: TRAIL_SEGMENTS },
        uSpeedMult: { value: DEFAULT_CONFIG.particleSpeed / 100 },
        uColorShift: { value: DEFAULT_CONFIG.colorShift / 360 },
        uBrightness: { value: DEFAULT_CONFIG.trailBrightness / 100 },
        uUndulation: { value: DEFAULT_CONFIG.undulation / 100 }
      },
      vertexShader: `
        attribute float pathIndex;
        attribute float pathLength;
        attribute float aScale;
        attribute float speed;
        attribute float phase;
        attribute float timeOffset;
        attribute float colorSeed;
        attribute float trailIndex;
        
        uniform float uTime;
        uniform sampler2D uPathTex;
        uniform vec2 uPathSize;
        uniform float uTrailSegments;
        uniform float uSpeedMult;
        uniform float uUndulation;
        
        varying float vAlpha;
        varying float vHeight;
        varying float vProgress;
        varying float vColorSeed;
        varying float vPhase;
        varying float vTrailFade;
        varying float vWrap; // 1.0 if this segment crosses wrap boundary
        
        float hash(float n) { return fract(sin(n) * 43758.5453); }
        float noise(float x) {
          float i = floor(x), f = fract(x);
          f = f * f * (3.0 - 2.0 * f);
          return mix(hash(i), hash(i + 1.0), f);
        }
        
        vec4 getPathPt(float pi, float idx) {
          return texture2D(uPathTex, vec2((idx + 0.5) / uPathSize.x, (pi + 0.5) / uPathSize.y));
        }
        
        void main() {
          vColorSeed = colorSeed;
          vPhase = phase;
          
          float baseTime = uTime * uSpeedMult + timeOffset;
          float noiseOffset = (noise(phase * 10.0) - 0.5) * 0.08;
          
          // Trail offset - each point is behind in time
          float trailOffset = trailIndex * 0.5;
          float time = baseTime - trailOffset;
          
          // Compute t with noise in single mod to avoid double-wrap issues
          float rawT = time * speed + noiseOffset;
          float t = mod(rawT, 1.0);
          
          // Detect wrap-around BEFORE position calculation
          // Compute raw t for adjacent trail points (same noise since phase is constant)
          float rawTPrev = (baseTime - (trailIndex - 1.0) * 0.5) * speed + noiseOffset;
          float rawTNext = (baseTime - (trailIndex + 1.0) * 0.5) * speed + noiseOffset;
          
          // Check if this vertex and its neighbors are in different "cycles"
          // floor(rawT) gives the cycle number - if they differ, the segment wraps
          float cycleCurrent = floor(rawT);
          float cyclePrev = floor(rawTPrev);
          float cycleNext = floor(rawTNext);
          
          float wrapPrev = abs(cycleCurrent - cyclePrev) > 0.5 ? 1.0 : 0.0;
          float wrapNext = abs(cycleCurrent - cycleNext) > 0.5 ? 1.0 : 0.0;
          vWrap = max(wrapPrev, wrapNext);
          
          float segCount = pathLength - 1.0;
          float segProg = t * segCount;
          float segIdx = floor(segProg);
          float segT = fract(segProg);
          
          // Catmull-Rom interpolation
          vec4 p0 = getPathPt(pathIndex, max(0.0, segIdx - 1.0));
          vec4 p1 = getPathPt(pathIndex, segIdx);
          vec4 p2 = getPathPt(pathIndex, min(segIdx + 1.0, pathLength - 1.0));
          vec4 p3 = getPathPt(pathIndex, min(segIdx + 2.0, pathLength - 1.0));
          
          float t2 = segT * segT, t3 = t2 * segT;
          vec3 pos = 0.5 * (
            2.0 * p1.xyz +
            (-p0.xyz + p2.xyz) * segT +
            (2.0 * p0.xyz - 5.0 * p1.xyz + 4.0 * p2.xyz - p3.xyz) * t2 +
            (-p0.xyz + 3.0 * p1.xyz - 3.0 * p2.xyz + p3.xyz) * t3
          );
          
          // Undulation - branches sway gently
          float heightFactor = smoothstep(0.0, 20.0, pos.y); // More sway at top
          float branchPhase = pathIndex * 0.73 + segIdx * 0.31; // Unique phase per branch segment
          float swayTime = uTime * 0.15;
          
          // Multi-frequency sway for organic feel
          float swayX = sin(swayTime + branchPhase) * 0.7 
                      + sin(swayTime * 1.7 + branchPhase * 2.3) * 0.3;
          float swayZ = sin(swayTime * 0.8 + branchPhase * 1.5 + 1.57) * 0.7 
                      + sin(swayTime * 1.3 + branchPhase * 1.8) * 0.3;
          
          float swayAmount = uUndulation * heightFactor * (0.5 + t * 0.5); // More sway toward branch tips
          pos.x += swayX * swayAmount;
          pos.z += swayZ * swayAmount;
          
          vHeight = pos.y;
          float thick = mix(p1.w, p2.w, segT);
          
          // Drift perpendicular to path
          vec3 tangent = normalize(p2.xyz - p1.xyz + 0.001);
          vec3 perp1 = normalize(cross(tangent, vec3(0.0, 1.0, 0.1)));
          vec3 perp2 = normalize(cross(tangent, perp1));
          
          float ns1 = phase * 10.0 + time * 0.2;
          float ns2 = phase * 7.0 + time * 0.25;
          
          float d1 = (noise(ns1 + t * 2.0) - 0.5) * 0.8;
          d1 += sin(phase * 3.0 + time * 0.2 + t * 1.5) * 0.3;
          float d2 = (noise(ns2 + t * 1.8) - 0.5) * 0.8;
          d2 += cos(phase * 2.0 + time * 0.15 + t * 1.2) * 0.3;
          
          float driftMult = thick * 0.5 + 0.05;
          driftMult *= 1.0 + t * 0.5;
          
          d1 *= driftMult;
          d2 *= driftMult;
          
          float vDrift = (noise(phase * 13.0 + t * 1.5) - 0.5) * thick * 0.2;
          pos += perp1 * d1 + perp2 * d2 + vec3(0.0, vDrift, 0.0);
          
          // Trail fade - head is bright, tail fades out
          vTrailFade = 1.0 - (trailIndex / (uTrailSegments + 1.0));
          vTrailFade = pow(max(vTrailFade, 0.0), 0.8);
          
          vProgress = t;
          
          // Alpha
          float alphaBase = smoothstep(0.0, 0.05, t) * smoothstep(1.0, 0.8, t);
          vAlpha = alphaBase * (0.3 + 0.7 * vTrailFade);
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uColorShift;
        uniform float uBrightness;
        
        varying float vAlpha;
        varying float vHeight;
        varying float vProgress;
        varying float vColorSeed;
        varying float vPhase;
        varying float vTrailFade;
        varying float vWrap;
        
        // Hue shift function
        vec3 hueShift(vec3 color, float shift) {
          float angle = shift * 6.28318;
          float s = sin(angle);
          float c = cos(angle);
          vec3 weights = vec3(0.299, 0.587, 0.114);
          float wSum = dot(color, weights);
          vec3 c1 = vec3(wSum);
          vec3 c2 = color - c1;
          return c1 + vec3(
            c2.r * c - (c2.g * 0.328 - c2.b * 0.883) * s,
            c2.g * c + (c2.r * 0.328 + c2.b * 0.557) * s,
            c2.b * c - (c2.r * 0.883 + c2.g * 0.557) * s
          );
        }
        
        void main() {
          // Hide segments that wrap around
          if (vWrap > 0.5) discard;
          float h = clamp(vHeight / 22.0, 0.0, 1.0);
          
          // Rich color palette
          vec3 cyan = vec3(0.0, 0.92, 1.0);
          vec3 teal = vec3(0.0, 1.0, 0.85);
          vec3 violet = vec3(0.6, 0.3, 1.0);
          vec3 magenta = vec3(1.0, 0.2, 0.7);
          vec3 gold = vec3(1.0, 0.8, 0.0);
          vec3 white = vec3(1.0, 0.98, 0.95);
          
          // Base color from seed
          float colorMix = vColorSeed + sin(uTime * 0.15 + vPhase) * 0.15;
          vec3 baseColor;
          if (colorMix < 0.25) {
            baseColor = mix(cyan, teal, colorMix * 4.0);
          } else if (colorMix < 0.5) {
            baseColor = mix(teal, violet, (colorMix - 0.25) * 4.0);
          } else if (colorMix < 0.75) {
            baseColor = mix(violet, magenta, (colorMix - 0.5) * 4.0);
          } else {
            baseColor = mix(magenta, cyan, (colorMix - 0.75) * 4.0);
          }
          
          // Height-based color shift
          vec3 color = mix(baseColor, violet, h * 0.4);
          color = mix(color, gold, h * h * 0.3);
          
          // Shimmer
          float shimmer = sin(uTime * 4.0 + vPhase * 12.0 + vProgress * 30.0) * 0.5 + 0.5;
          shimmer *= sin(uTime * 2.5 + vPhase * 8.0) * 0.5 + 0.5;
          color += gold * pow(shimmer, 3.0) * vProgress * 0.5;
          
          // Rare bright sparkle
          float sparkle = pow(max(0.0, sin(uTime * 1.2 + vPhase * 25.0 + vProgress * 15.0)), 20.0);
          color += white * sparkle * 0.7;
          
          // Core brightness
          color *= 0.95 + (1.0 - vProgress) * 0.1;
          
          // Apply hue shift and brightness controls
          color = hueShift(color, uColorShift);
          color *= uBrightness;
          
          gl_FragColor = vec4(color, vAlpha * 0.15);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const treeMesh = new THREE.LineSegments(geo, treeMat);
    treeMesh.frustumCulled = false;
    
    // Create a group for the tree and related elements so they can rotate together
    const treeGroup = new THREE.Group();
    treeGroup.add(treeMesh);
    scene.add(treeGroup);

    // Tip sparks - single sparks shooting from random tips
    function createTipSparks() {
      const NUM_SPARKS = 8; // Spark "slots" - staggered so ~1 visible at a time
      const SPARK_TRAIL_LENGTH = 10;
      const SPARK_TRAIL_SEGMENTS = SPARK_TRAIL_LENGTH - 1;
      const TOTAL_SPARK_VERTICES = NUM_SPARKS * SPARK_TRAIL_SEGMENTS * 2;
      
      const sparkGeo = new THREE.BufferGeometry();
      const sparkPositions = new Float32Array(TOTAL_SPARK_VERTICES * 3);
      sparkGeo.setAttribute('position', new THREE.BufferAttribute(sparkPositions, 3));
      
      // Attributes for each spark vertex
      const sparkIndices = new Float32Array(TOTAL_SPARK_VERTICES);
      const sparkTrailIndices = new Float32Array(TOTAL_SPARK_VERTICES);
      const sparkSpeeds = new Float32Array(TOTAL_SPARK_VERTICES);
      
      let vertIdx = 0;
      for (let spark = 0; spark < NUM_SPARKS; spark++) {
        const speed = 0.8 + Math.random() * 0.4;
        
        for (let seg = 0; seg < SPARK_TRAIL_SEGMENTS; seg++) {
          sparkIndices[vertIdx] = spark;
          sparkTrailIndices[vertIdx] = seg;
          sparkSpeeds[vertIdx] = speed;
          vertIdx++;
          sparkIndices[vertIdx] = spark;
          sparkTrailIndices[vertIdx] = seg + 1;
          sparkSpeeds[vertIdx] = speed;
          vertIdx++;
        }
      }
      
      sparkGeo.setAttribute('sparkIndex', new THREE.BufferAttribute(sparkIndices, 1));
      sparkGeo.setAttribute('sparkTrailIndex', new THREE.BufferAttribute(sparkTrailIndices, 1));
      sparkGeo.setAttribute('sparkSpeed', new THREE.BufferAttribute(sparkSpeeds, 1));
      
      // Store ALL tip positions in texture - shader picks randomly
      const numTips = paths.length;
      const tipData = new Float32Array(numTips * 4);
      paths.forEach((path, i) => {
        const lastBranch = path[path.length - 1];
        tipData[i * 4 + 0] = lastBranch.end.x;
        tipData[i * 4 + 1] = lastBranch.end.y;
        tipData[i * 4 + 2] = lastBranch.end.z;
        tipData[i * 4 + 3] = 1.0;
      });
      const tipTex = new THREE.DataTexture(tipData, numTips, 1, THREE.RGBAFormat, THREE.FloatType);
      tipTex.needsUpdate = true;
      
      const sparkMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uTipTex: { value: tipTex },
          uNumTips: { value: numTips },
          uNumSparks: { value: NUM_SPARKS },
          uTrailSegments: { value: SPARK_TRAIL_SEGMENTS }
        },
        vertexShader: `
          attribute float sparkIndex;
          attribute float sparkTrailIndex;
          attribute float sparkSpeed;
          
          uniform float uTime;
          uniform sampler2D uTipTex;
          uniform float uNumTips;
          uniform float uNumSparks;
          uniform float uTrailSegments;
          
          varying float vAlpha;
          varying float vTrailFade;
          varying float vColorMix;
          
          float hash(float n) { return fract(sin(n) * 43758.5453); }
          
          void main() {
            // Each spark fires every 3.5 sec, staggered across all sparks
            float sparkInterval = 3.5;
            float sparkOffset = sparkIndex * sparkInterval / uNumSparks;
            
            float globalTime = uTime + sparkOffset;
            float cycleIndex = floor(globalTime / sparkInterval);
            float localTime = mod(globalTime, sparkInterval);
            
            // Pick random tip based on cycle
            float tipIndex = floor(hash(cycleIndex * 13.0 + sparkIndex * 7.0) * uNumTips);
            vec4 tipPos = texture2D(uTipTex, vec2((tipIndex + 0.5) / uNumTips, 0.5));
            
            // Trail offset
            float trailOffset = sparkTrailIndex * 0.03;
            float t = localTime - trailOffset;
            
            // Rise for ~1.2 seconds
            float riseTime = 1.2;
            float life = t / riseTime;
            
            // Position: shoot straight up
            vec3 pos = tipPos.xyz;
            pos.y += max(0.0, t) * 10.0 * sparkSpeed;
            
            // Trail fade
            vTrailFade = 1.0 - (sparkTrailIndex / uTrailSegments);
            vTrailFade = pow(max(vTrailFade, 0.0), 0.5);
            
            // Alpha
            float fadeIn = smoothstep(0.0, 0.1, life);
            float fadeOut = 1.0 - smoothstep(0.5, 1.0, life);
            vAlpha = fadeIn * fadeOut * vTrailFade;
            
            if (t < 0.0 || life > 1.0) vAlpha = 0.0;
            
            vColorMix = hash(cycleIndex + sparkIndex);
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          varying float vTrailFade;
          varying float vColorMix;
          
          void main() {
            if (vAlpha < 0.01) discard;
            
            // Bright spark colors - white/gold/cyan
            vec3 white = vec3(1.0, 1.0, 1.0);
            vec3 gold = vec3(1.0, 0.85, 0.4);
            vec3 cyan = vec3(0.4, 0.9, 1.0);
            
            vec3 color = mix(gold, cyan, sin(vColorMix * 6.28) * 0.5 + 0.5);
            color = mix(color, white, vTrailFade * 0.5);
            
            gl_FragColor = vec4(color, vAlpha * 0.6);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const sparkMesh = new THREE.LineSegments(sparkGeo, sparkMat);
      sparkMesh.frustumCulled = false;
      
      return { mesh: sparkMesh, material: sparkMat, tipTex };
    }
    
    const tipSparks = createTipSparks();
    treeGroup.add(tipSparks.mesh);

    // Shooting stars - streaking down and to the left
    function createShootingStars() {
      const NUM_STARS = 12;
      const TRAIL_LENGTH = 15;
      const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;
      const TOTAL_VERTICES = NUM_STARS * TRAIL_SEGMENTS * 2;
      
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(TOTAL_VERTICES * 3);
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const starIndices = new Float32Array(TOTAL_VERTICES);
      const trailIndices = new Float32Array(TOTAL_VERTICES);
      const starSpeeds = new Float32Array(TOTAL_VERTICES);
      
      let vertIdx = 0;
      for (let star = 0; star < NUM_STARS; star++) {
        const speed = 0.7 + Math.random() * 0.5;
        for (let seg = 0; seg < TRAIL_SEGMENTS; seg++) {
          starIndices[vertIdx] = star;
          trailIndices[vertIdx] = seg;
          starSpeeds[vertIdx] = speed;
          vertIdx++;
          starIndices[vertIdx] = star;
          trailIndices[vertIdx] = seg + 1;
          starSpeeds[vertIdx] = speed;
          vertIdx++;
        }
      }
      
      geo.setAttribute('starIndex', new THREE.BufferAttribute(starIndices, 1));
      geo.setAttribute('trailIndex', new THREE.BufferAttribute(trailIndices, 1));
      geo.setAttribute('starSpeed', new THREE.BufferAttribute(starSpeeds, 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uNumStars: { value: NUM_STARS },
          uTrailSegments: { value: TRAIL_SEGMENTS }
        },
        vertexShader: `
          attribute float starIndex;
          attribute float trailIndex;
          attribute float starSpeed;
          
          uniform float uTime;
          uniform float uNumStars;
          uniform float uTrailSegments;
          
          varying float vAlpha;
          varying float vTrailFade;
          
          float hash(float n) { return fract(sin(n) * 43758.5453); }
          float hash2(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
          
          void main() {
            // Each star fires every ~8 seconds, staggered
            float starInterval = 8.0;
            float starOffset = starIndex * starInterval / uNumStars;
            
            float globalTime = uTime + starOffset;
            float cycleIndex = floor(globalTime / starInterval);
            float localTime = mod(globalTime, starInterval);
            
            // Random start position in sky for this cycle
            float randX = hash(cycleIndex * 7.0 + starIndex * 13.0);
            float randY = hash(cycleIndex * 11.0 + starIndex * 17.0);
            float randZ = hash(cycleIndex * 19.0 + starIndex * 23.0);
            
            // Start high up and spread across sky
            vec3 startPos = vec3(
              (randX - 0.5) * 80.0 + 20.0,  // Shifted right so they enter from right
              30.0 + randY * 30.0,           // High up
              (randZ - 0.5) * 60.0 - 30.0    // Spread in Z, shifted back
            );
            
            // Direction: down and to the left (negative X, negative Y)
            vec3 direction = normalize(vec3(-1.0, -0.7, 0.3));
            float speed = 25.0 * starSpeed;
            
            // Trail offset
            float trailOffset = trailIndex * 0.02;
            float t = localTime - trailOffset;
            
            // Visible for ~2 seconds
            float lifetime = 2.5;
            float life = t / lifetime;
            
            vec3 pos = startPos + direction * t * speed;
            
            // Trail fade
            vTrailFade = 1.0 - (trailIndex / uTrailSegments);
            vTrailFade = pow(max(vTrailFade, 0.0), 0.4);
            
            // Alpha
            float fadeIn = smoothstep(0.0, 0.05, life);
            float fadeOut = 1.0 - smoothstep(0.7, 1.0, life);
            vAlpha = fadeIn * fadeOut * vTrailFade;
            
            if (t < 0.0 || life > 1.0) vAlpha = 0.0;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          varying float vTrailFade;
          
          void main() {
            if (vAlpha < 0.01) discard;
            
            // White/blue shooting star
            vec3 white = vec3(1.0, 1.0, 1.0);
            vec3 blue = vec3(0.7, 0.85, 1.0);
            vec3 color = mix(blue, white, vTrailFade);
            
            gl_FragColor = vec4(color, vAlpha * 0.8);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const mesh = new THREE.LineSegments(geo, mat);
      mesh.frustumCulled = false;
      return { mesh, material: mat };
    }
    
    const shootingStars = createShootingStars();
    scene.add(shootingStars.mesh);

    // Horizontal flowing fog - subtle and cloudlike
    function createFog() {
      const geo = new THREE.PlaneGeometry(120, 60, 1, 1);
      const mat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float uTime;
          varying vec2 vUv;
          
          // Simplex-ish noise functions for detailed clouds
          vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
          
          float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                               -0.577350269189626, 0.024390243902439);
            vec2 i  = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
            m = m*m; m = m*m;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
            vec3 g;
            g.x = a0.x * x0.x + h.x * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
          }
          
          float fbm(vec2 p) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            for (int i = 0; i < 6; i++) {
              value += amplitude * snoise(p * frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
            }
            return value;
          }
          
          void main() {
            vec2 uv = vUv;
            
            // Horizontal drift
            float drift = uTime * 0.015;
            
            // Multi-layered cloud noise
            vec2 p1 = uv * vec2(3.0, 1.5) + vec2(drift, 0.0);
            vec2 p2 = uv * vec2(5.0, 2.0) + vec2(drift * 1.3, uTime * 0.005);
            vec2 p3 = uv * vec2(8.0, 3.0) + vec2(drift * 0.7, -uTime * 0.003);
            
            float cloud1 = fbm(p1) * 0.5 + 0.5;
            float cloud2 = fbm(p2) * 0.5 + 0.5;
            float cloud3 = fbm(p3) * 0.5 + 0.5;
            
            // Combine layers with sharper edges
            float clouds = cloud1 * 0.5 + cloud2 * 0.3 + cloud3 * 0.2;
            
            // Sharp cloud lines - tight smoothstep for defined edges
            float sharpClouds = smoothstep(0.48, 0.53, clouds);
            // Add some wispy detail at lower opacity
            float wispyClouds = smoothstep(0.4, 0.65, clouds) * 0.3;
            clouds = sharpClouds * 0.7 + wispyClouds;
            
            // Fade at edges
            float edgeFade = smoothstep(0.0, 0.25, uv.x) * smoothstep(1.0, 0.75, uv.x);
            edgeFade *= smoothstep(0.0, 0.2, uv.y) * smoothstep(1.0, 0.8, uv.y);
            
            // Blue/violet tinted
            vec3 fogColor = vec3(0.45, 0.5, 0.65);
            
            // Visible but not overwhelming
            float alpha = clouds * edgeFade * 0.15;
            
            gl_FragColor = vec4(fogColor, alpha);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      
      const layers = [];
      // Multiple fog layers - will billboard to always face camera
      const layerConfigs = [
        { y: 6, z: -40, scale: 1.3 },
        { y: 14, z: -50, scale: 1.6 },
        { y: 20, z: -35, scale: 1.1 },
      ];
      
      layerConfigs.forEach(config => {
        const mesh = new THREE.Mesh(geo.clone(), mat.clone());
        mesh.position.set(0, config.y, config.z);
        mesh.scale.setScalar(config.scale);
        mesh.userData.material = mesh.material;
        mesh.userData.basePosition = { y: config.y, z: config.z };
        layers.push(mesh);
      });
      
      return layers;
    }
    
    const fogLayers = createFog();
    fogLayers.forEach(layer => scene.add(layer));

    // Rising energy particles - going up and OUT, slow and ethereal
    function createRisingEnergy() {
      const count = 600;
      const positions = new Float32Array(count * 3);
      const phases = new Float32Array(count);
      const speeds = new Float32Array(count);
      
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 0.5 + Math.random() * 3;
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = Math.sin(angle) * radius;
        phases[i] = Math.random() * Math.PI * 2;
        speeds[i] = 0.06 + Math.random() * 0.1; // Much slower
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
      geo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
          attribute float phase;
          attribute float speed;
          varying float vAlpha;
          varying vec3 vColor;
          uniform float uTime;
          void main() {
            float time = uTime * speed + phase;
            float life = mod(time, 1.0);
            
            vec3 pos = position;
            pos.y = life * 30.0;
            
            // Spiral OUTWARD as they rise
            float angle = time * 0.8 + phase * 3.0;
            float expand = 1.0 + life * life * 10.0;
            pos.x = position.x * expand * cos(angle) - position.z * expand * sin(angle);
            pos.z = position.x * expand * sin(angle) + position.z * expand * cos(angle);
            
            // Fade in then out
            vAlpha = sin(life * 3.14159) * 0.6;
            
            // Color gradient from cyan to violet as they rise
            vColor = mix(vec3(0.0, 0.9, 1.0), vec3(0.6, 0.3, 1.0), life);
            
            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = (1.0 + life * 2.0) * (50.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          varying vec3 vColor;
          void main() {
            float d = length(gl_PointCoord - 0.5);
            float a = 1.0 - smoothstep(0.0, 0.5, d);
            a += exp(-d * 4.0) * 0.4;
            gl_FragColor = vec4(vColor, a * vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }
    const risingEnergy = createRisingEnergy();
    treeGroup.add(risingEnergy);

    // Camera animation state
    let cameraAnimation = null;
    
    // Rotation speed (controlled by slider)
    let rotationSpeed = (DEFAULT_CONFIG.treeRotation / 100) * 0.05;
    
    // Animation
    function animate(time) {
      const t = time * 0.001;
      
      treeMat.uniforms.uTime.value = t;
      stars.material.uniforms.uTime.value = t;
      moon.material.uniforms.uTime.value = t;
      risingEnergy.material.uniforms.uTime.value = t;
      tipSparks.material.uniforms.uTime.value = t;
      shootingStars.material.uniforms.uTime.value = t;
      
      // Fog layers billboard - always face camera but don't rotate
      fogLayers.forEach(layer => {
        if (layer.userData.material) layer.userData.material.uniforms.uTime.value = t;
        // Make fog face camera
        layer.lookAt(camera.position);
      });
      
      etherealPass.uniforms.uTime.value = t;
      
      // Rotate the tree group slowly (stars stay fixed)
      treeGroup.rotation.y = t * rotationSpeed;
      
      // Update camera animation if active
      if (cameraAnimation && cameraAnimation.active) {
        cameraAnimation.update(time);
      }
      
      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    
    animate(0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Debug Panel
    const debugPanel = document.getElementById('debugPanel');
    const btnRegenerate = document.getElementById('btnRegenerate');
    const btnTopDownZoom = document.getElementById('btnTopDownZoom');
    const btnResetCamera = document.getElementById('btnResetCamera');
    const chkStars = document.getElementById('chkStars');
    const chkRisingParticles = document.getElementById('chkRisingParticles');
    const chkShootingStars = document.getElementById('chkShootingStars');
    const sliderStarDensity = document.getElementById('sliderStarDensity');
    const starDensityValue = document.getElementById('starDensityValue');
    
    // New slider references
    const sliderRotation = document.getElementById('sliderRotation');
    const rotationValue = document.getElementById('rotationValue');
    const sliderBloom = document.getElementById('sliderBloom');
    const bloomValue = document.getElementById('bloomValue');
    const sliderSpeed = document.getElementById('sliderSpeed');
    const speedValue = document.getElementById('speedValue');
    const sliderColorShift = document.getElementById('sliderColorShift');
    const colorShiftValue = document.getElementById('colorShiftValue');
    const sliderTrailBrightness = document.getElementById('sliderTrailBrightness');
    const trailBrightnessValue = document.getElementById('trailBrightnessValue');
    const sliderMoonPhase = document.getElementById('sliderMoonPhase');
    const moonPhaseValue = document.getElementById('moonPhaseValue');
    const sliderMoonRotation = document.getElementById('sliderMoonRotation');
    const moonRotationValue = document.getElementById('moonRotationValue');
    const sliderMoonOcclusion = document.getElementById('sliderMoonOcclusion');
    const moonOcclusionValue = document.getElementById('moonOcclusionValue');
    const sliderUndulation = document.getElementById('sliderUndulation');
    const undulationValue = document.getElementById('undulationValue');
    
    // LocalStorage persistence
    const STORAGE_KEY = 'particleForestSettings';
    
    // Get current config in the same format as DEFAULT_CONFIG
    function getCurrentConfig() {
      return {
        starDensity: parseInt(sliderStarDensity.value),
        treeRotation: parseInt(sliderRotation.value),
        bloom: parseInt(sliderBloom.value),
        particleSpeed: parseInt(sliderSpeed.value),
        colorShift: parseInt(sliderColorShift.value),
        trailBrightness: parseInt(sliderTrailBrightness.value),
        undulation: parseInt(sliderUndulation.value),
        moonPhase: parseInt(sliderMoonPhase.value),
        moonRotation: parseInt(sliderMoonRotation.value),
        moonOcclusion: parseInt(sliderMoonOcclusion.value),
        showStars: chkStars.checked,
        showRisingSparks: chkRisingParticles.checked,
        showShootingStars: chkShootingStars.checked
      };
    }
    
    function saveSettings() {
      const rect = debugPanel.getBoundingClientRect();
      const settings = {
        debugOpen: debugPanel.classList.contains('visible'),
        panelX: debugPanel.style.left ? rect.left : null,
        panelY: debugPanel.style.top ? rect.top : null,
        chkStars: chkStars.checked,
        chkRisingParticles: chkRisingParticles.checked,
        chkShootingStars: chkShootingStars.checked,
        starDensity: sliderStarDensity.value,
        rotation: sliderRotation.value,
        bloom: sliderBloom.value,
        speed: sliderSpeed.value,
        colorShift: sliderColorShift.value,
        trailBrightness: sliderTrailBrightness.value,
        undulation: sliderUndulation.value,
        moonPhase: sliderMoonPhase.value,
        moonRotation: sliderMoonRotation.value,
        moonOcclusion: sliderMoonOcclusion.value
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    }
    
    function loadSettings() {
      const saved = localStorage.getItem(STORAGE_KEY);
      
      // Always sync UI with current values (from DEFAULT_CONFIG or localStorage)
      function applyConfig(config) {
        // Sliders
        sliderStarDensity.value = config.starDensity;
        starDensityValue.textContent = config.starDensity + '%';
        
        sliderRotation.value = config.treeRotation;
        rotationValue.textContent = config.treeRotation + '%';
        
        sliderBloom.value = config.bloom;
        bloomValue.textContent = config.bloom + '%';
        
        sliderSpeed.value = config.particleSpeed;
        speedValue.textContent = config.particleSpeed + '%';
        
        sliderColorShift.value = config.colorShift;
        colorShiftValue.textContent = config.colorShift + '°';
        
        sliderTrailBrightness.value = config.trailBrightness;
        trailBrightnessValue.textContent = config.trailBrightness + '%';
        
        sliderUndulation.value = config.undulation;
        undulationValue.textContent = config.undulation + '%';
        
        sliderMoonPhase.value = config.moonPhase;
        const phasePercent = config.moonPhase;
        moonPhaseValue.textContent = phasePercent === 0 ? 'New' : phasePercent === 100 ? 'Full' : phasePercent + '%';
        
        sliderMoonRotation.value = config.moonRotation;
        moonRotationValue.textContent = config.moonRotation + '°';
        
        sliderMoonOcclusion.value = config.moonOcclusion;
        moonOcclusionValue.textContent = config.moonOcclusion + '%';
        
        // Checkboxes
        chkStars.checked = config.showStars;
        stars.visible = config.showStars;
        
        chkRisingParticles.checked = config.showRisingSparks;
        tipSparks.mesh.visible = config.showRisingSparks;
        
        chkShootingStars.checked = config.showShootingStars;
        shootingStars.mesh.visible = config.showShootingStars;
      }
      
      // Start with DEFAULT_CONFIG
      applyConfig(DEFAULT_CONFIG);
      
      if (!saved) return;
      
      try {
        const settings = JSON.parse(saved);
        
        // Debug panel visibility and position
        if (settings.debugOpen) {
          debugPanel.classList.add('visible');
        }
        if (settings.panelX !== null && settings.panelY !== null) {
          debugPanel.style.left = settings.panelX + 'px';
          debugPanel.style.top = settings.panelY + 'px';
          debugPanel.style.right = 'auto';
        }
        
        // Override with saved settings
        if (settings.starDensity !== undefined) {
          sliderStarDensity.value = settings.starDensity;
          stars.material.uniforms.uDensity.value = settings.starDensity / 100;
          starDensityValue.textContent = settings.starDensity + '%';
        }
        if (settings.rotation !== undefined) {
          sliderRotation.value = settings.rotation;
          rotationSpeed = (settings.rotation / 100) * 0.05;
          rotationValue.textContent = settings.rotation + '%';
        }
        if (settings.bloom !== undefined) {
          sliderBloom.value = settings.bloom;
          bloomPass.strength = settings.bloom / 100;
          bloomValue.textContent = settings.bloom + '%';
        }
        if (settings.speed !== undefined) {
          sliderSpeed.value = settings.speed;
          treeMat.uniforms.uSpeedMult.value = settings.speed / 100;
          speedValue.textContent = settings.speed + '%';
        }
        if (settings.colorShift !== undefined) {
          sliderColorShift.value = settings.colorShift;
          treeMat.uniforms.uColorShift.value = settings.colorShift / 360;
          colorShiftValue.textContent = settings.colorShift + '°';
        }
        if (settings.trailBrightness !== undefined) {
          sliderTrailBrightness.value = settings.trailBrightness;
          treeMat.uniforms.uBrightness.value = settings.trailBrightness / 100;
          trailBrightnessValue.textContent = settings.trailBrightness + '%';
        }
        if (settings.undulation !== undefined) {
          sliderUndulation.value = settings.undulation;
          treeMat.uniforms.uUndulation.value = settings.undulation / 100;
          undulationValue.textContent = settings.undulation + '%';
        }
        if (settings.moonPhase !== undefined) {
          sliderMoonPhase.value = settings.moonPhase;
          moon.material.uniforms.uPhase.value = settings.moonPhase / 100;
          const phasePercent = parseInt(settings.moonPhase);
          moonPhaseValue.textContent = phasePercent === 0 ? 'New' : phasePercent === 100 ? 'Full' : phasePercent + '%';
        }
        if (settings.moonRotation !== undefined) {
          sliderMoonRotation.value = settings.moonRotation;
          moon.material.uniforms.uRotation.value = (settings.moonRotation / 360) * Math.PI * 2;
          moonRotationValue.textContent = settings.moonRotation + '°';
        }
        if (settings.moonOcclusion !== undefined) {
          sliderMoonOcclusion.value = settings.moonOcclusion;
          moon.material.uniforms.uOcclusion.value = settings.moonOcclusion / 100;
          moonOcclusionValue.textContent = settings.moonOcclusion + '%';
        }
        if (settings.chkStars !== undefined) {
          chkStars.checked = settings.chkStars;
          stars.visible = settings.chkStars;
        }
        if (settings.chkRisingParticles !== undefined) {
          chkRisingParticles.checked = settings.chkRisingParticles;
          tipSparks.mesh.visible = settings.chkRisingParticles;
        }
        if (settings.chkShootingStars !== undefined) {
          chkShootingStars.checked = settings.chkShootingStars;
          shootingStars.mesh.visible = settings.chkShootingStars;
        }
      } catch (e) {
        console.error('Failed to load settings:', e);
      }
    }
    
    // Load saved settings on startup
    loadSettings();
    
    // Toggle visibility checkboxes
    chkStars.addEventListener('change', () => {
      stars.visible = chkStars.checked;
      saveSettings();
    });
    
    // Star density slider
    sliderStarDensity.addEventListener('input', () => {
      const density = sliderStarDensity.value / 100;
      stars.material.uniforms.uDensity.value = density;
      starDensityValue.textContent = sliderStarDensity.value + '%';
      saveSettings();
    });
    chkRisingParticles.addEventListener('change', () => {
      tipSparks.mesh.visible = chkRisingParticles.checked;
      saveSettings();
    });
    chkShootingStars.addEventListener('change', () => {
      shootingStars.mesh.visible = chkShootingStars.checked;
      saveSettings();
    });
    
    // Tree rotation speed
    sliderRotation.addEventListener('input', () => {
      rotationSpeed = (sliderRotation.value / 100) * 0.05;
      rotationValue.textContent = sliderRotation.value + '%';
      saveSettings();
    });
    
    // Bloom intensity
    sliderBloom.addEventListener('input', () => {
      bloomPass.strength = sliderBloom.value / 100;
      bloomValue.textContent = sliderBloom.value + '%';
      saveSettings();
    });
    
    // Particle speed
    sliderSpeed.addEventListener('input', () => {
      treeMat.uniforms.uSpeedMult.value = sliderSpeed.value / 100;
      speedValue.textContent = sliderSpeed.value + '%';
      saveSettings();
    });
    
    // Color shift
    sliderColorShift.addEventListener('input', () => {
      const degrees = parseInt(sliderColorShift.value);
      treeMat.uniforms.uColorShift.value = degrees / 360;
      colorShiftValue.textContent = degrees + '°';
      saveSettings();
    });
    
    // Trail brightness
    sliderTrailBrightness.addEventListener('input', () => {
      treeMat.uniforms.uBrightness.value = sliderTrailBrightness.value / 100;
      trailBrightnessValue.textContent = sliderTrailBrightness.value + '%';
      saveSettings();
    });
    
    // Branch undulation/sway
    sliderUndulation.addEventListener('input', () => {
      treeMat.uniforms.uUndulation.value = sliderUndulation.value / 100;
      undulationValue.textContent = sliderUndulation.value + '%';
      saveSettings();
    });
    
    // Moon phase
    sliderMoonPhase.addEventListener('input', () => {
      const phase = sliderMoonPhase.value / 100;
      moon.material.uniforms.uPhase.value = phase;
      const phasePercent = parseInt(sliderMoonPhase.value);
      moonPhaseValue.textContent = phasePercent === 0 ? 'New' : phasePercent === 100 ? 'Full' : phasePercent + '%';
      saveSettings();
    });
    
    // Moon rotation
    sliderMoonRotation.addEventListener('input', () => {
      const degrees = parseInt(sliderMoonRotation.value);
      moon.material.uniforms.uRotation.value = (degrees / 360) * Math.PI * 2;
      moonRotationValue.textContent = degrees + '°';
      saveSettings();
    });
    
    // Moon occlusion size
    sliderMoonOcclusion.addEventListener('input', () => {
      moon.material.uniforms.uOcclusion.value = sliderMoonOcclusion.value / 100;
      moonOcclusionValue.textContent = sliderMoonOcclusion.value + '%';
      saveSettings();
    });
    
    // Toggle debug panel with 'D' key
    window.addEventListener('keydown', (e) => {
      if (e.key === 'd' || e.key === 'D') {
        debugPanel.classList.toggle('visible');
        saveSettings();
      }
    });
    
    // Make debug panel draggable
    const panelHeader = debugPanel.querySelector('h3');
    let isDragging = false;
    let dragStartX, dragStartY, panelStartX, panelStartY;
    
    panelHeader.addEventListener('mousedown', (e) => {
      isDragging = true;
      debugPanel.classList.add('dragging');
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      const rect = debugPanel.getBoundingClientRect();
      panelStartX = rect.left;
      panelStartY = rect.top;
      e.preventDefault();
    });
    
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      let newX = panelStartX + dx;
      let newY = panelStartY + dy;
      
      // Keep panel on screen
      const rect = debugPanel.getBoundingClientRect();
      newX = Math.max(0, Math.min(window.innerWidth - rect.width, newX));
      newY = Math.max(0, Math.min(window.innerHeight - rect.height, newY));
      
      debugPanel.style.left = newX + 'px';
      debugPanel.style.top = newY + 'px';
      debugPanel.style.right = 'auto';
    });
    
    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        debugPanel.classList.remove('dragging');
        saveSettings();
      }
    });
    
    // Dev tools buttons
    const btnCopyConfig = document.getElementById('btnCopyConfig');
    const btnReload = document.getElementById('btnReload');
    const chkLiveReload = document.getElementById('chkLiveReload');
    let liveReloadInterval = null;
    
    btnCopyConfig.addEventListener('click', async () => {
      const config = getCurrentConfig();
      const configStr = `const DEFAULT_CONFIG = ${JSON.stringify(config, null, 2)};`;
      try {
        await navigator.clipboard.writeText(configStr);
        btnCopyConfig.textContent = 'Copied!';
        setTimeout(() => {
          btnCopyConfig.textContent = 'Copy Config to Clipboard';
        }, 1500);
      } catch (e) {
        // Fallback: show in console
        console.log('Copy this to DEFAULT_CONFIG:\n', configStr);
        btnCopyConfig.textContent = 'Check Console';
        setTimeout(() => {
          btnCopyConfig.textContent = 'Copy Config to Clipboard';
        }, 1500);
      }
    });
    
    btnReload.addEventListener('click', () => {
      location.reload();
    });
    
    chkLiveReload.addEventListener('change', () => {
      if (chkLiveReload.checked) {
        // Start polling for file changes
        let lastModified = null;
        liveReloadInterval = setInterval(async () => {
          try {
            const response = await fetch(location.href, { method: 'HEAD' });
            const modified = response.headers.get('last-modified');
            if (lastModified && modified !== lastModified) {
              location.reload();
            }
            lastModified = modified;
          } catch (e) {
            // Ignore fetch errors
          }
        }, 2000);
      } else {
        if (liveReloadInterval) {
          clearInterval(liveReloadInterval);
          liveReloadInterval = null;
        }
      }
    });
    
    // Regenerate tree
    btnRegenerate.addEventListener('click', () => {
      // Generate new tree
      const newTree = generateTree();
      const newPaths = newTree.paths;
      
      // Update path texture
      const newPathTexH = newPaths.length;
      const newPathData = new Float32Array(pathTexW * newPathTexH * 4);
      
      newPaths.forEach((path, pi) => {
        let idx = 0;
        newPathData[(pi * pathTexW + idx) * 4 + 0] = path[0].start.x;
        newPathData[(pi * pathTexW + idx) * 4 + 1] = path[0].start.y;
        newPathData[(pi * pathTexW + idx) * 4 + 2] = path[0].start.z;
        newPathData[(pi * pathTexW + idx) * 4 + 3] = path[0].thickness;
        idx++;
        
        for (let b = 0; b < path.length && idx < MAX_PATH; b++) {
          newPathData[(pi * pathTexW + idx) * 4 + 0] = path[b].end.x;
          newPathData[(pi * pathTexW + idx) * 4 + 1] = path[b].end.y;
          newPathData[(pi * pathTexW + idx) * 4 + 2] = path[b].end.z;
          newPathData[(pi * pathTexW + idx) * 4 + 3] = path[b].thickness;
          idx++;
        }
        
        const last = path[path.length - 1];
        while (idx < MAX_PATH) {
          newPathData[(pi * pathTexW + idx) * 4 + 0] = last.end.x;
          newPathData[(pi * pathTexW + idx) * 4 + 1] = last.end.y;
          newPathData[(pi * pathTexW + idx) * 4 + 2] = last.end.z;
          newPathData[(pi * pathTexW + idx) * 4 + 3] = last.thickness;
          idx++;
        }
      });
      
      // Create new texture and update material
      const newPathTex = new THREE.DataTexture(newPathData, pathTexW, newPathTexH, THREE.RGBAFormat, THREE.FloatType);
      newPathTex.needsUpdate = true;
      treeMat.uniforms.uPathTex.value = newPathTex;
      treeMat.uniforms.uPathSize.value.y = newPathTexH;
      
      // Update particle path indices - must keep same path for all vertices of a particle
      // Each particle has TRAIL_SEGMENTS * 2 vertices
      const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;
      const verticesPerParticle = TRAIL_SEGMENTS * 2;
      const pathIndicesAttr = geo.getAttribute('pathIndex');
      const pathLengthsAttr = geo.getAttribute('pathLength');
      
      for (let p = 0; p < PARTICLES; p++) {
        const pi = Math.floor(Math.random() * newPaths.length);
        const pathLen = Math.min(newPaths[pi].length + 1, MAX_PATH);
        
        // Set same path index and length for all vertices of this particle
        for (let v = 0; v < verticesPerParticle; v++) {
          const idx = p * verticesPerParticle + v;
          if (idx < pathIndicesAttr.count) {
            pathIndicesAttr.array[idx] = pi;
            pathLengthsAttr.array[idx] = pathLen;
          }
        }
      }
      pathIndicesAttr.needsUpdate = true;
      pathLengthsAttr.needsUpdate = true;
      
      // Update tip sparks texture with all tips
      const newTipData = new Float32Array(newPaths.length * 4);
      newPaths.forEach((path, i) => {
        const lastBranch = path[path.length - 1];
        newTipData[i * 4 + 0] = lastBranch.end.x;
        newTipData[i * 4 + 1] = lastBranch.end.y;
        newTipData[i * 4 + 2] = lastBranch.end.z;
        newTipData[i * 4 + 3] = 1.0;
      });
      const newTipTex = new THREE.DataTexture(newTipData, newPaths.length, 1, THREE.RGBAFormat, THREE.FloatType);
      newTipTex.needsUpdate = true;
      tipSparks.material.uniforms.uTipTex.value = newTipTex;
      tipSparks.material.uniforms.uNumTips.value = newPaths.length;
    });
    
    // Top Down Zoom camera animation
    btnTopDownZoom.addEventListener('click', () => {
      // Stop any existing animation
      if (cameraAnimation) {
        cameraAnimation.active = false;
      }
      
      // Disable orbit controls during animation
      controls.enabled = false;
      controls.autoRotate = false;
      
      // Animation parameters
      const startY = 50;
      const endY = -5;
      const duration = 20000; // 20 seconds
      const startTime = performance.now();
      
      cameraAnimation = {
        active: true,
        update: (time) => {
          if (!cameraAnimation.active) return;
          
          const elapsed = time - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Ease in-out
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          const y = startY + (endY - startY) * eased;
          
          camera.position.set(0, y, 0.01);
          camera.lookAt(0, y - 1, 0);
          
          if (progress >= 1) {
            cameraAnimation.active = false;
          }
        }
      };
      
      btnTopDownZoom.classList.add('active');
    });
    
    // Reset camera
    btnResetCamera.addEventListener('click', () => {
      if (cameraAnimation) {
        cameraAnimation.active = false;
      }
      
      controls.enabled = true;
      camera.position.set(0, 10, 35);
      camera.lookAt(0, 12, 0);
      controls.target.set(0, 10, 0);
      
      btnTopDownZoom.classList.remove('active');
    });
  </script>
</body>
</html>
