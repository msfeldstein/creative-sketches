<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Song Manager - Audio Signal Editor</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0b;
      --bg-light: #111113;
      --bg-lighter: #1a1a1e;
      --bg-track: #0d0d0f;
      --text: #e8e8e8;
      --text-dim: #555;
      --accent: #ff6b35;
      --accent-dim: rgba(255, 107, 53, 0.2);
      --cyan: #00d4ff;
      --green: #00ff88;
      --purple: #a855f7;
      --yellow: #fbbf24;
      --border: rgba(255, 255, 255, 0.06);
      --track-height: 50px;
      --track-header-width: 200px;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-light);
      height: 50px;
    }

    header h1 {
      font-size: 0.7rem;
      font-weight: 400;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    header .header-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    header a, header button {
      color: var(--text-dim);
      text-decoration: none;
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      background: none;
      border: 1px solid var(--border);
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    header a:hover, header button:hover {
      color: var(--accent);
      border-color: var(--accent);
    }

    /* Main Layout - see Song List section for .container and .sidebar styles */

    .sidebar-section {
      padding: 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    .sidebar h2 {
      font-size: 0.6rem;
      font-weight: 400;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-bottom: 0.5rem;
    }

    /* Drop Zone */
    .drop-zone {
      border: 1px dashed var(--border);
      border-radius: 6px;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.7rem;
      color: var(--text-dim);
    }

    .drop-zone:hover, .drop-zone.dragover {
      border-color: var(--accent);
      background: var(--accent-dim);
      color: var(--text);
    }

    .drop-zone input { display: none; }

    /* Song List */
    .song-list {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }

    /* Main Layout */
    .container {
      display: flex;
      height: calc(100vh - 50px);
      position: relative;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      min-width: 220px;
      background: var(--bg-light);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transform: translateX(0);
      transition: transform 0.25s ease;
    }

    .container.sidebar-collapsed .sidebar {
      transform: translateX(-220px);
    }

    /* Sidebar Toggle */
    .sidebar-toggle {
      position: absolute;
      left: 220px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 48px;
      background: var(--bg-lighter);
      border: 1px solid var(--border);
      border-left: none;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      font-size: 0.6rem;
      z-index: 10;
      transition: left 0.25s ease;
    }

    .sidebar-toggle:hover {
      background: var(--bg-light);
      color: var(--accent);
    }

    .sidebar-toggle .toggle-icon {
      transition: transform 0.25s ease;
    }

    .container.sidebar-collapsed .sidebar-toggle {
      left: 0;
    }

    .container.sidebar-collapsed .sidebar-toggle .toggle-icon {
      transform: rotate(180deg);
    }

    .container.sidebar-collapsed .timeline-editor {
      margin-left: -220px;
    }

    .song-item {
      background: var(--bg-lighter);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.6rem 0.75rem;
      margin-bottom: 0.4rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .song-item:hover { border-color: rgba(255,255,255,0.15); }
    .song-item.active { border-color: var(--accent); background: var(--accent-dim); }

    .song-item .name {
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .song-item .meta {
      font-size: 0.6rem;
      color: var(--text-dim);
      margin-top: 0.2rem;
    }

    /* Timeline Editor */
    .timeline-editor {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      flex: 1;
      min-width: 0;
      transition: margin-left 0.25s ease;
    }

    .timeline-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-dim);
      font-size: 0.8rem;
    }

    /* Transport Bar */
    .transport-bar {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 1rem;
      background: var(--bg-light);
      border-bottom: 1px solid var(--border);
      height: 44px;
    }

    .transport-bar button {
      background: var(--bg-lighter);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.4rem 0.8rem;
      color: var(--text);
      font-family: inherit;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .transport-bar button:hover { border-color: var(--accent); }
    .transport-bar button:disabled { opacity: 0.4; cursor: not-allowed; }
    .transport-bar button.playing { background: var(--accent); border-color: var(--accent); }

    .transport-bar .time-display {
      font-size: 0.8rem;
      color: var(--text-dim);
      min-width: 100px;
    }

    .transport-bar .bpm-display {
      font-size: 0.7rem;
      color: var(--cyan);
      margin-left: auto;
    }

    .transport-bar .add-track-btn {
      margin-left: 1rem;
      background: var(--green);
      border-color: var(--green);
      color: #000;
    }

    .transport-bar .add-track-btn:hover {
      background: #00ff99;
      border-color: #00ff99;
    }

    /* Timeline Container */
    .timeline-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Waveform Track (always first) */
    .waveform-track {
      display: flex;
      height: 80px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-track);
    }

    .waveform-track .track-header {
      width: var(--track-header-width);
      min-width: var(--track-header-width);
      padding: 0.5rem;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .waveform-track .track-header .label {
      font-size: 0.65rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .waveform-track .track-content {
      flex: 1;
      position: relative;
    }

    .waveform-track canvas {
      width: 100%;
      height: 100%;
    }

    /* Signal Track */
    .signal-track {
      display: flex;
      height: var(--track-height);
      border-bottom: 1px solid var(--border);
      background: var(--bg-track);
      transition: height 0.2s;
    }

    .signal-track .track-header {
      width: var(--track-header-width);
      min-width: var(--track-header-width);
      padding: 0.3rem 0.5rem;
      border-right: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
      overflow: hidden;
    }

    .signal-track .track-header .value-bar {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 0%;
      opacity: 0.3;
      transition: width 0.05s ease-out;
      pointer-events: none;
    }

    .signal-track[data-type="beat"] .value-bar { background: var(--accent); }
    .signal-track[data-type="frequency"] .value-bar { background: var(--purple); }
    .signal-track[data-type="automation"] .value-bar { background: var(--cyan); }
    .signal-track[data-type="trigger"] .value-bar { background: var(--yellow); }

    .signal-track .track-header .track-name {
      font-size: 0.7rem;
      background: none;
      border: none;
      color: var(--text);
      position: relative;
      z-index: 1;
      padding: 0;
      width: 70px;
      min-width: 70px;
      outline: none;
      cursor: text;
    }

    .signal-track .track-header .track-name:hover {
      color: var(--accent);
    }

    .signal-track .track-header .track-type {
      font-size: 0.5rem;
      color: var(--text-dim);
      text-transform: uppercase;
      position: relative;
      z-index: 1;
      flex: 1;
    }

    .signal-track .track-header .track-value {
      font-size: 0.7rem;
      color: #fff;
      font-weight: 600;
      min-width: 35px;
      text-align: right;
      position: relative;
      z-index: 1;
      text-shadow: 0 0 10px currentColor;
    }

    .signal-track .track-header .delete-track-btn {
      background: transparent;
      border: none;
      color: var(--text-dim);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0.2rem 0.4rem;
      opacity: 0.5;
      z-index: 2;
      margin-left: auto;
      padding: 0.15rem 0.3rem;
      border-radius: 2px;
    }

    .signal-track .track-header .delete-track-btn:hover {
      color: #ff4444;
      opacity: 1;
    }

    .signal-track .track-header:hover {
      background: var(--bg-lighter);
    }

    .signal-track .track-header:hover .track-type {
      color: var(--accent);
    }

    .signal-track .track-content {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .signal-track canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    /* Envelope Controls - appears below the full track row */
    .envelope-controls {
      display: none;
      background: var(--bg-lighter);
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 1rem;
      gap: 1.5rem;
      align-items: center;
    }

    .envelope-controls.visible {
      display: flex;
    }

    .envelope-controls .control-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .envelope-controls label {
      font-size: 0.55rem;
      color: var(--text-dim);
      text-transform: uppercase;
      min-width: 45px;
    }

    .envelope-controls input[type="range"] {
      width: 70px;
      height: 4px;
      cursor: pointer;
    }

    .envelope-controls input[type="number"] {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.2rem 0.3rem;
      font-size: 0.6rem;
      border-radius: 3px;
      width: 55px;
    }

    .envelope-controls select {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.2rem 0.3rem;
      font-size: 0.6rem;
      border-radius: 3px;
    }

    /* Playhead */
    .playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent);
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 0 8px var(--accent);
    }

    /* Add Track Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.visible { display: flex; }

    .modal {
      background: var(--bg-light);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      min-width: 320px;
    }

    .modal h3 {
      font-size: 0.8rem;
      font-weight: 500;
      margin-bottom: 1rem;
      color: var(--text);
    }

    .modal .track-type-options {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .modal .track-type-option {
      background: var(--bg-lighter);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal .track-type-option:hover {
      border-color: var(--accent);
    }

    .modal .track-type-option .option-title {
      font-size: 0.75rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .modal .track-type-option .option-desc {
      font-size: 0.65rem;
      color: var(--text-dim);
    }

    .modal .modal-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 1rem;
    }

    .modal button {
      background: var(--bg-lighter);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.5rem 1rem;
      color: var(--text);
      font-family: inherit;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .modal button:hover { border-color: var(--accent); }

    /* Export Section */
    .export-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--bg-light);
      border-top: 1px solid var(--border);
    }

    .export-bar button {
      background: var(--bg-lighter);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.4rem 0.8rem;
      color: var(--text);
      font-family: inherit;
      font-size: 0.65rem;
      cursor: pointer;
    }

    .export-bar button:hover { border-color: var(--accent); }
    .export-bar button.primary { background: var(--green); border-color: var(--green); color: #000; }
    .export-bar button.primary:hover { background: #00ff99; }

    .export-bar .spacer { flex: 1; }

    .export-bar .audio-path-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .export-bar .audio-path-group label {
      font-size: 0.6rem;
      color: var(--text-dim);
    }

    .export-bar .audio-path-input {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.3rem 0.5rem;
      font-size: 0.65rem;
      font-family: inherit;
      border-radius: 4px;
      width: 200px;
    }

    .export-bar .audio-path-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .export-bar .audio-path-input::placeholder {
      color: var(--text-dim);
    }

    /* Track Colors */
    .signal-track[data-type="beat"] .track-type { color: var(--accent); }
    .signal-track[data-type="frequency"] .track-type { color: var(--purple); }
    .signal-track[data-type="automation"] .track-type { color: var(--cyan); }
    .signal-track[data-type="trigger"] .track-type { color: var(--yellow); }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

    /* Analysis Progress */
    .analysis-overlay {
      position: absolute;
      inset: 0;
      background: rgba(10, 10, 11, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 500;
    }

    .analysis-overlay .spinner {
      width: 32px;
      height: 32px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .analysis-overlay p { font-size: 0.8rem; color: var(--text-dim); }
    .analysis-overlay .progress-bar {
      width: 200px;
      height: 3px;
      background: var(--border);
      border-radius: 2px;
      margin-top: 0.75rem;
      overflow: hidden;
    }
    .analysis-overlay .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.1s;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--bg-light);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.25rem 0;
      min-width: 180px;
      z-index: 2000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .context-menu-item {
      padding: 0.5rem 0.75rem;
      font-size: 0.7rem;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .context-menu-item:hover {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .context-menu-item .shortcut {
      margin-left: auto;
      color: var(--text-dim);
      font-size: 0.6rem;
    }

    .context-menu-separator {
      height: 1px;
      background: var(--border);
      margin: 0.25rem 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>Signal Editor</h1>
    <div class="header-controls">
      <a href="/">‚Üê Sketches</a>
    </div>
  </header>

  <div class="container" id="mainContainer">
    <button class="sidebar-toggle" id="sidebarToggle" title="Toggle sidebar">
      <span class="toggle-icon">‚óÄ</span>
    </button>
    <aside class="sidebar">
      <div class="sidebar-section">
        <h2>Import</h2>
        <div class="drop-zone" id="dropZone">
          Click or drop MP3
          <input type="file" id="fileInput" accept="audio/*">
        </div>
      </div>
      <h2 style="padding: 0.5rem 0.75rem 0;">Songs</h2>
      <div class="song-list" id="songList"></div>
    </aside>

    <main class="timeline-editor" id="timelineEditor">
      <div class="timeline-placeholder">Select or import a song to begin</div>
    </main>
  </div>

  <!-- Add Track Modal -->
  <div class="modal-overlay" id="addTrackModal">
    <div class="modal">
      <h3>Add Signal Track</h3>
      <div class="track-type-options">
        <div class="track-type-option" data-type="beat">
          <div class="option-title">Beat Detection</div>
          <div class="option-desc">Auto-detected kicks, snares, hi-hats, or all beats</div>
        </div>
        <div class="track-type-option" data-type="frequency">
          <div class="option-title">Frequency Band</div>
          <div class="option-desc">Sub, bass, mid, or high frequency energy</div>
        </div>
        <div class="track-type-option" data-type="automation">
          <div class="option-title">Automation Curve</div>
          <div class="option-desc">Draw custom value curves over time</div>
        </div>
        <div class="track-type-option" data-type="trigger">
          <div class="option-title">Trigger Events</div>
          <div class="option-desc">Piano roll style - place events at specific times</div>
        </div>
      </div>
      <div class="modal-actions">
        <button id="cancelAddTrack">Cancel</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { analyzeAudio, decodeAudio, generateWaveform } from '/lib/audio-analyzer.js';
    import { AudioSignals } from '/lib/audio-signals.js';

    // State
    let songs = [];
    let currentSong = null;
    let audioBuffer = null;
    let waveformData = null;
    let isAnalyzing = false;
    
    // Playback
    const signals = new AudioSignals();
    let animationFrame = null;
    let playheadTime = 0;
    
    // IndexedDB for songs (metadata + audio data)
    let db = null;
    const DB_NAME = 'AudioTracksDB';
    const DB_VERSION = 2;
    const SONGS_STORE = 'songs';
    const HANDLE_STORE = 'fileHandles'; // Legacy, kept for migration

    // Track type configurations
    const TRACK_CONFIGS = {
      beat: {
        subtypes: ['all', 'kicks', 'snares', 'hihats'],
        defaultName: 'Beats',
        color: '#ff6b35'
      },
      frequency: {
        subtypes: ['sub', 'bass', 'mid', 'high'],
        defaultName: 'Frequency',
        color: '#a855f7'
      },
      automation: {
        subtypes: null,
        defaultName: 'Automation',
        color: '#00d4ff'
      },
      trigger: {
        subtypes: null,
        defaultName: 'Triggers',
        color: '#fbbf24'
      }
    };

    // DOM Elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const songList = document.getElementById('songList');
    const timelineEditor = document.getElementById('timelineEditor');
    const addTrackModal = document.getElementById('addTrackModal');

    // Initialize
    initDB().then(async () => {
      await loadSongsFromDB();
      renderSongList();
      initSidebarToggle();
    });

    // Sidebar collapse functionality
    function initSidebarToggle() {
      const container = document.getElementById('mainContainer');
      const toggle = document.getElementById('sidebarToggle');
      
      // Load collapsed state from storage
      const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
      if (isCollapsed) {
        container.classList.add('sidebar-collapsed');
      }
      
      toggle.addEventListener('click', () => {
        const collapsed = container.classList.toggle('sidebar-collapsed');
        localStorage.setItem('sidebarCollapsed', collapsed);
        
        // Redraw canvases after transition completes (they may have resized)
        setTimeout(() => {
          if (currentSong) {
            drawWaveform();
            drawAllTracks();
          }
        }, 300);
      });
    }

    // IndexedDB setup
    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { db = request.result; resolve(db); };
        request.onupgradeneeded = (e) => {
          const database = e.target.result;
          
          // Create songs store for full song data including audio
          if (!database.objectStoreNames.contains(SONGS_STORE)) {
            database.createObjectStore(SONGS_STORE, { keyPath: 'id' });
          }
          
          // Keep legacy handle store for migration
          if (!database.objectStoreNames.contains(HANDLE_STORE)) {
            database.createObjectStore(HANDLE_STORE, { keyPath: 'id' });
          }
        };
      });
    }

    // Store a complete song (metadata + audio data) in IndexedDB
    async function storeSongInDB(song) {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const tx = db.transaction([SONGS_STORE], 'readwrite');
        // Store everything including audioData as ArrayBuffer
        const songData = {
          id: song.id,
          name: song.name,
          fileName: song.fileName,
          audioPath: song.audioPath,
          duration: song.duration,
          bpm: song.bpm,
          beats: song.beats,
          frequency: song.frequency,
          energy: song.energy,
          waveform: song.waveform,
          signalTracks: song.signalTracks,
          audioData: song.audioData // ArrayBuffer - IndexedDB handles this efficiently
        };
        tx.objectStore(SONGS_STORE).put(songData);
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
      });
    }

    // Load a song from IndexedDB
    async function loadSongFromDB(id) {
      if (!db) return null;
      return new Promise((resolve, reject) => {
        const tx = db.transaction([SONGS_STORE], 'readonly');
        const req = tx.objectStore(SONGS_STORE).get(id);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    // Load all songs from IndexedDB
    async function loadAllSongsFromDB() {
      if (!db) return [];
      return new Promise((resolve, reject) => {
        const tx = db.transaction([SONGS_STORE], 'readonly');
        const req = tx.objectStore(SONGS_STORE).getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }

    // Delete a song from IndexedDB
    async function deleteSongFromDB(id) {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const tx = db.transaction([SONGS_STORE], 'readwrite');
        tx.objectStore(SONGS_STORE).delete(id);
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
      });
    }

    // Legacy: get file handle (for migration only)
    async function getFileHandle(id) {
      if (!db || !db.objectStoreNames.contains(HANDLE_STORE)) return null;
      return new Promise((resolve, reject) => {
        try {
          const tx = db.transaction([HANDLE_STORE], 'readonly');
          const req = tx.objectStore(HANDLE_STORE).get(id);
          req.onsuccess = () => resolve(req.result?.handle || null);
          req.onerror = () => reject(req.error);
        } catch (e) {
          resolve(null);
        }
      });
    }

    async function getFileFromHandle(handle) {
      if (!handle) return null;
      try {
        const permission = await handle.queryPermission({ mode: 'read' });
        if (permission === 'granted') return await handle.getFile();
        const newPerm = await handle.requestPermission({ mode: 'read' });
        if (newPerm === 'granted') return await handle.getFile();
      } catch (e) {
        console.warn('File handle error:', e);
      }
      return null;
    }

    // File upload
    dropZone.addEventListener('click', async () => {
      if ('showOpenFilePicker' in window) {
        try {
          const [handle] = await window.showOpenFilePicker({
            types: [{ description: 'Audio', accept: { 'audio/*': ['.mp3', '.wav', '.ogg', '.m4a'] } }]
          });
          const file = await handle.getFile();
          processFile(file, handle);
        } catch (e) { if (e.name !== 'AbortError') console.error(e); }
      } else {
        fileInput.click();
      }
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files[0]) processFile(e.target.files[0], null);
    });

    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) processFile(file, null);
    });

    async function processFile(file, fileHandle) {
      if (isAnalyzing) return;
      isAnalyzing = true;
      
      renderAnalysisProgress();
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const audioDataCopy = arrayBuffer.slice(0);
        audioBuffer = await decodeAudio(arrayBuffer);
        waveformData = generateWaveform(audioBuffer, 2000);
        
        const analysis = await analyzeAudio(audioBuffer, updateAnalysisProgress);
        analysis.name = file.name.replace(/\.[^/.]+$/, '');
        
        const songId = Date.now().toString();
        
        // Create default signal tracks from analysis
        const signalTracks = [
          { id: 't1', name: 'All Beats', type: 'beat', subtype: 'all', attack: 0, decay: 0.1, expanded: false },
          { id: 't2', name: 'Bass', type: 'frequency', subtype: 'bass', attack: 0.01, decay: 0.1, expanded: false, minHz: 60, maxHz: 250, gain: 1, smoothing: 0 },
          { id: 't3', name: 'High', type: 'frequency', subtype: 'high', attack: 0.01, decay: 0.1, expanded: false, minHz: 2000, maxHz: 20000, gain: 1, smoothing: 0 },
        ];
        
        const song = {
          id: songId,
          ...analysis,
          fileName: file.name,
          audioData: audioDataCopy, // Store actual audio data in IndexedDB
          waveform: Array.from(waveformData),
          signalTracks
        };
        
        songs.push(song);
        await saveSong(song); // Save to IndexedDB
        renderSongList();
        selectSong(songId);
        
      } catch (error) {
        console.error('Error processing file:', error);
        alert('Error: ' + error.message);
      }
      
      isAnalyzing = false;
    }

    function renderAnalysisProgress() {
      timelineEditor.innerHTML = `
        <div class="analysis-overlay">
          <div class="spinner"></div>
          <p id="analysisStatus">Decoding audio...</p>
          <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
        </div>
      `;
    }

    function updateAnalysisProgress(progress) {
      const status = document.getElementById('analysisStatus');
      const fill = document.getElementById('progressFill');
      if (status) {
        if (progress < 0.5) status.textContent = 'Analyzing frequencies...';
        else if (progress < 0.9) status.textContent = 'Detecting beats...';
        else status.textContent = 'Finalizing...';
      }
      if (fill) fill.style.width = Math.round(progress * 100) + '%';
    }

    // Song selection
    async function selectSong(songId) {
      currentSong = songs.find(s => s.id === songId);
      if (!currentSong) return;
      
      document.querySelectorAll('.song-item').forEach(el => {
        el.classList.toggle('active', el.dataset.id === songId);
      });
      
      if (currentSong.waveform?.length) {
        waveformData = new Float32Array(currentSong.waveform);
      }
      
      // Load audio from stored data
      if (currentSong.audioData?.byteLength > 0) {
        const blob = new Blob([currentSong.audioData], { type: 'audio/mpeg' });
        const url = URL.createObjectURL(blob);
        await signals.loadTrackData(currentSong, url);
      }
      
      renderTimeline();
    }

    function renderSongList() {
      songList.innerHTML = songs.map(song => `
        <div class="song-item ${currentSong?.id === song.id ? 'active' : ''}" data-id="${song.id}">
          <div class="name">${song.name}</div>
          <div class="meta">${formatTime(song.duration)} ‚Ä¢ ${song.bpm} BPM</div>
        </div>
      `).join('');
      
      document.querySelectorAll('.song-item').forEach(el => {
        el.addEventListener('click', () => selectSong(el.dataset.id));
      });
    }

    // Timeline rendering
    function renderTimeline() {
      if (!currentSong) {
        timelineEditor.innerHTML = '<div class="timeline-placeholder">Select or import a song to begin</div>';
        return;
      }
      
      const hasAudio = currentSong.audioData?.byteLength > 0;
      
      timelineEditor.innerHTML = `
        <div class="transport-bar">
          ${!hasAudio ? `<button id="linkAudioBtn" style="background:var(--accent);border-color:var(--accent);">üîó Link Audio File</button>` : ''}
          <button id="playBtn" ${!hasAudio ? 'disabled' : ''}>‚ñ∂ Play</button>
          <button id="stopBtn" ${!hasAudio ? 'disabled' : ''}>‚ñ† Stop</button>
          <div class="time-display">
            <span id="currentTime">0:00.0</span> / ${formatTime(currentSong.duration)}
          </div>
          ${!hasAudio ? '<span style="color:var(--accent);font-size:0.7rem;">Audio not loaded</span>' : ''}
          <div class="bpm-display">${currentSong.bpm} BPM</div>
          <button class="add-track-btn" id="addTrackBtn">+ Add Track</button>
        </div>
        
        <div class="timeline-container" id="timelineContainer">
          <div class="waveform-track">
            <div class="track-header">
              <div class="label">Waveform</div>
            </div>
            <div class="track-content">
              <canvas id="waveformCanvas"></canvas>
              <div class="playhead" id="playhead" style="left:0"></div>
            </div>
          </div>
          
          <div id="signalTracksContainer"></div>
        </div>
        
        <div class="export-bar">
          <div class="audio-path-group">
            <label>Audio URL:</label>
            <input type="text" class="audio-path-input" id="audioPathInput" 
                   value="${currentSong.audioPath || ''}" 
                   placeholder="/public/audio/${currentSong.fileName || 'song.mp3'}">
          </div>
          <button class="primary" id="exportBtn">Export JSON</button>
          <button id="copyBtn">Copy</button>
          <span class="spacer"></span>
          <button id="deleteBtn" style="color:var(--accent)">Delete Song</button>
        </div>
      `;
      
      setupTimelineEvents();
      renderSignalTracks();
      drawWaveform();
    }

    function renderSignalTracks() {
      const container = document.getElementById('signalTracksContainer');
      if (!container || !currentSong) return;
      
      container.innerHTML = currentSong.signalTracks.map((track, index) => `
        <div class="signal-track" data-type="${track.type}" data-index="${index}">
          <div class="track-header">
            <div class="value-bar" id="valueBar${index}"></div>
            <input class="track-name" value="${track.name}" data-index="${index}">
            <div class="track-type">${track.subtype || track.type}</div>
            <div class="track-value" id="trackValue${index}">0.00</div>
            <button class="delete-track-btn" data-index="${index}" title="Delete track">√ó</button>
          </div>
          <div class="track-content">
            <canvas id="trackCanvas${index}"></canvas>
          </div>
        </div>
        <div class="envelope-controls ${track.expanded ? 'visible' : ''}" data-index="${index}">
          <div class="control-group">
            <label>Attack</label>
            <input type="range" min="0" max="500" value="${track.attack * 1000}" data-index="${index}" data-param="attack">
          </div>
          <div class="control-group">
            <label>Decay</label>
            <input type="range" min="0" max="1000" value="${track.decay * 1000}" data-index="${index}" data-param="decay">
          </div>
          ${track.type === 'beat' ? `
            <div class="control-group">
              <label>Type</label>
              <select data-index="${index}" data-param="subtype">
                ${['all', 'kicks', 'snares', 'hihats'].map(t =>
                  `<option value="${t}" ${track.subtype === t ? 'selected' : ''}>${t}</option>`
                ).join('')}
              </select>
            </div>
          ` : ''}
          ${track.type === 'frequency' ? `
            <div class="control-group">
              <label>Band</label>
              <select data-index="${index}" data-param="subtype">
                ${['sub', 'bass', 'mid', 'high', 'custom'].map(t =>
                  `<option value="${t}" ${track.subtype === t ? 'selected' : ''}>${t}</option>`
                ).join('')}
              </select>
            </div>
            <div class="control-group">
              <label>Min Hz</label>
              <input type="number" min="20" max="20000" value="${track.minHz || 20}" data-index="${index}" data-param="minHz">
            </div>
            <div class="control-group">
              <label>Max Hz</label>
              <input type="number" min="20" max="20000" value="${track.maxHz || 20000}" data-index="${index}" data-param="maxHz">
            </div>
            <div class="control-group">
              <label>Gain</label>
              <input type="range" min="0" max="300" value="${(track.gain || 1) * 100}" data-index="${index}" data-param="gain">
            </div>
            <div class="control-group">
              <label>Smooth</label>
              <input type="range" min="0" max="100" value="${(track.smoothing || 0) * 100}" data-index="${index}" data-param="smoothing">
            </div>
          ` : ''}
        </div>
      `).join('');
      
      // Setup track events
      container.querySelectorAll('.track-name').forEach(input => {
        input.addEventListener('change', (e) => {
          const idx = parseInt(e.target.dataset.index);
          currentSong.signalTracks[idx].name = e.target.value;
          saveSongsToStorage();
        });
      });
      
      // Make entire track header clickable to expand (except inputs and delete button)
      container.querySelectorAll('.track-header').forEach(header => {
        header.addEventListener('click', (e) => {
          // Don't expand if clicking on input, select, or delete button
          if (e.target.matches('input, select, button.delete-track-btn')) return;
          
          const track = header.closest('.signal-track');
          const idx = parseInt(track.dataset.index);
          currentSong.signalTracks[idx].expanded = !currentSong.signalTracks[idx].expanded;
          
          // Toggle the envelope controls visibility
          const controls = container.querySelector(`.envelope-controls[data-index="${idx}"]`);
          if (controls) {
            controls.classList.toggle('visible');
          }
          saveSongsToStorage();
        });
        header.style.cursor = 'pointer';
      });
      
      container.querySelectorAll('.delete-track-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't trigger header expand
          const idx = parseInt(e.target.dataset.index);
          currentSong.signalTracks.splice(idx, 1);
          saveSongsToStorage();
          renderSignalTracks();
        });
      });
      
      container.querySelectorAll('input[type="range"]').forEach(input => {
        input.addEventListener('input', (e) => {
          const idx = parseInt(e.target.dataset.index);
          const param = e.target.dataset.param;
          const track = currentSong.signalTracks[idx];
          
          if (param === 'attack' || param === 'decay') {
            track[param] = e.target.value / 1000;
          } else if (param === 'gain') {
            track.gain = e.target.value / 100;
          } else if (param === 'smoothing') {
            track.smoothing = e.target.value / 100;
            track._smoothedValue = undefined; // Reset smoothed value
          }
          saveSongsToStorage();
        });
      });

      container.querySelectorAll('input[type="number"]').forEach(input => {
        input.addEventListener('change', (e) => {
          const idx = parseInt(e.target.dataset.index);
          const param = e.target.dataset.param;
          const track = currentSong.signalTracks[idx];
          
          if (param === 'minHz' || param === 'maxHz') {
            track[param] = Math.max(20, Math.min(20000, parseInt(e.target.value) || 20));
            track.subtype = 'custom'; // Auto-switch to custom when Hz is changed
          }
          saveSongsToStorage();
          drawTrack(idx);
        });
      });

      container.querySelectorAll('select').forEach(select => {
        select.addEventListener('change', (e) => {
          const idx = parseInt(e.target.dataset.index);
          const param = e.target.dataset.param;
          const track = currentSong.signalTracks[idx];
          
          if (param === 'subtype') {
            track.subtype = e.target.value;
            // Set default Hz ranges for preset bands
            const bandRanges = { sub: [20, 60], bass: [60, 250], mid: [250, 2000], high: [2000, 20000] };
            if (bandRanges[e.target.value]) {
              track.minHz = bandRanges[e.target.value][0];
              track.maxHz = bandRanges[e.target.value][1];
            }
          }
          saveSongsToStorage();
          renderSignalTracks(); // Re-render to update Hz inputs
          drawTrack(idx);
        });
      });
      
      // Setup automation/trigger canvas events and right-click context menus
      container.querySelectorAll('.signal-track').forEach((trackEl, idx) => {
        const track = currentSong.signalTracks[idx];
        const canvas = document.getElementById(`trackCanvas${idx}`);
        
        if (track.type === 'automation') {
          setupAutomationCanvas(canvas, idx);
        } else if (track.type === 'trigger') {
          setupTriggerCanvas(canvas, idx);
        }
        
        // Right-click context menu for all tracks
        trackEl.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showContextMenu(e.clientX, e.clientY, idx);
        });
      });
      
      drawAllTracks();
    }

    function setupAutomationCanvas(canvas, trackIndex) {
      const track = currentSong.signalTracks[trackIndex];
      if (!track.points) track.points = [[0, 0.5], [currentSong.duration, 0.5]];
      
      let draggingPoint = -1;
      
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const time = (x / rect.width) * currentSong.duration;
        const value = 1 - (y / rect.height);
        
        // Check for existing point
        for (let i = 0; i < track.points.length; i++) {
          const [pt, pv] = track.points[i];
          const px = (pt / currentSong.duration) * rect.width;
          const py = (1 - pv) * rect.height;
          if (Math.abs(x - px) < 8 && Math.abs(y - py) < 8) {
            draggingPoint = i;
            return;
          }
        }
        
        // Add new point
        let insertIdx = track.points.length;
        for (let i = 0; i < track.points.length; i++) {
          if (track.points[i][0] > time) { insertIdx = i; break; }
        }
        track.points.splice(insertIdx, 0, [time, Math.max(0, Math.min(1, value))]);
        draggingPoint = insertIdx;
        saveSongsToStorage();
        drawTrack(trackIndex);
      });
      
      canvas.addEventListener('mousemove', (e) => {
        if (draggingPoint < 0) return;
        const rect = canvas.getBoundingClientRect();
        let time = ((e.clientX - rect.left) / rect.width) * currentSong.duration;
        const value = 1 - ((e.clientY - rect.top) / rect.height);
        
        // Clamp time
        if (draggingPoint === 0) time = 0;
        else if (draggingPoint === track.points.length - 1) time = currentSong.duration;
        else {
          time = Math.max(track.points[draggingPoint - 1][0] + 0.01, 
                          Math.min(track.points[draggingPoint + 1][0] - 0.01, time));
        }
        
        track.points[draggingPoint] = [time, Math.max(0, Math.min(1, value))];
        drawTrack(trackIndex);
      });
      
      canvas.addEventListener('mouseup', () => {
        if (draggingPoint >= 0) saveSongsToStorage();
        draggingPoint = -1;
      });
      
      canvas.addEventListener('dblclick', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        for (let i = 1; i < track.points.length - 1; i++) {
          const [pt, pv] = track.points[i];
          const px = (pt / currentSong.duration) * rect.width;
          const py = (1 - pv) * rect.height;
          if (Math.abs(x - px) < 8 && Math.abs(y - py) < 8) {
            track.points.splice(i, 1);
            saveSongsToStorage();
            drawTrack(trackIndex);
            return;
          }
        }
      });
    }

    function setupTriggerCanvas(canvas, trackIndex) {
      const track = currentSong.signalTracks[trackIndex];
      if (!track.triggers) track.triggers = [];
      
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const time = (x / rect.width) * currentSong.duration;
        const velocity = 1 - (y / rect.height);
        
        // Check for existing trigger to remove
        for (let i = 0; i < track.triggers.length; i++) {
          const t = track.triggers[i];
          const tx = (t.time / currentSong.duration) * rect.width;
          if (Math.abs(x - tx) < 6) {
            track.triggers.splice(i, 1);
            saveSongsToStorage();
            drawTrack(trackIndex);
            return;
          }
        }
        
        // Add new trigger
        track.triggers.push({ time, velocity: Math.max(0.1, Math.min(1, velocity)) });
        track.triggers.sort((a, b) => a.time - b.time);
        saveSongsToStorage();
        drawTrack(trackIndex);
      });
    }

    function setupTimelineEvents() {
      document.getElementById('linkAudioBtn')?.addEventListener('click', linkAudioFile);
      document.getElementById('playBtn')?.addEventListener('click', togglePlay);
      document.getElementById('stopBtn')?.addEventListener('click', stop);
      document.getElementById('addTrackBtn')?.addEventListener('click', () => {
        addTrackModal.classList.add('visible');
      });
      document.getElementById('cancelAddTrack')?.addEventListener('click', () => {
        addTrackModal.classList.remove('visible');
      });
      document.getElementById('exportBtn')?.addEventListener('click', exportSong);
      document.getElementById('copyBtn')?.addEventListener('click', copySong);
      document.getElementById('deleteBtn')?.addEventListener('click', deleteSong);
      
      // Audio path input
      document.getElementById('audioPathInput')?.addEventListener('change', (e) => {
        currentSong.audioPath = e.target.value;
        saveSongsToStorage();
      });
      
      // Waveform click to seek
      document.getElementById('waveformCanvas')?.addEventListener('click', (e) => {
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        signals.seek(x * currentSong.duration);
        updatePlayhead();
      });
      
      // Track type selection in modal
      document.querySelectorAll('.track-type-option').forEach(opt => {
        opt.addEventListener('click', () => {
          addTrack(opt.dataset.type);
          addTrackModal.classList.remove('visible');
        });
      });
    }

    function addTrack(type) {
      const config = TRACK_CONFIGS[type];
      const newTrack = {
        id: 't' + Date.now(),
        name: config.defaultName,
        type,
        subtype: config.subtypes ? config.subtypes[0] : null,
        attack: 0.01,
        decay: 0.1,
        expanded: false
      };

      if (type === 'automation') {
        newTrack.points = [[0, 0.5], [currentSong.duration, 0.5]];
      } else if (type === 'trigger') {
        newTrack.triggers = [];
      } else if (type === 'frequency') {
        // Set default Hz range based on first subtype
        const bandRanges = { sub: [20, 60], bass: [60, 250], mid: [250, 2000], high: [2000, 20000] };
        const range = bandRanges[newTrack.subtype] || [20, 20000];
        newTrack.minHz = range[0];
        newTrack.maxHz = range[1];
        newTrack.gain = 1;
        newTrack.smoothing = 0;
      }

      currentSong.signalTracks.push(newTrack);
      saveSongsToStorage();
      renderSignalTracks();
    }

    // Link audio file to current song
    async function linkAudioFile() {
      if (!currentSong) return;
      
      if ('showOpenFilePicker' in window) {
        try {
          const [handle] = await window.showOpenFilePicker({
            types: [{ description: 'Audio', accept: { 'audio/*': ['.mp3', '.wav', '.ogg', '.m4a'] } }]
          });
          const file = await handle.getFile();
          const ab = await file.arrayBuffer();
          currentSong.audioData = ab.slice(0);
          
          // Save audio data to IndexedDB
          await saveSong(currentSong);
          
          // Load into audio player
          const blob = new Blob([currentSong.audioData], { type: 'audio/mpeg' });
          signals.loadTrackData(currentSong, URL.createObjectURL(blob));
          
          renderTimeline();
        } catch (e) {
          if (e.name !== 'AbortError') console.error('Link audio error:', e);
        }
      } else {
        // Fallback for browsers without File System Access API
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'audio/*';
        input.onchange = async () => {
          const file = input.files[0];
          if (file) {
            const ab = await file.arrayBuffer();
            currentSong.audioData = ab.slice(0);
            await saveSong(currentSong); // Save to IndexedDB
            const blob = new Blob([currentSong.audioData], { type: 'audio/mpeg' });
            signals.loadTrackData(currentSong, URL.createObjectURL(blob));
            renderTimeline();
          }
        };
        input.click();
      }
    }

    // Playback
    async function togglePlay() {
      const btn = document.getElementById('playBtn');
      if (signals.isPlaying()) {
        signals.pause();
        btn.textContent = '‚ñ∂ Play';
        btn.classList.remove('playing');
        cancelAnimationFrame(animationFrame);
      } else {
        try {
          await signals.play();
          btn.textContent = '‚ùö‚ùö Pause';
          btn.classList.add('playing');
          updateLoop();
        } catch (e) {
          console.error('Playback error:', e);
          alert('Could not play audio. Try re-linking the audio file.');
        }
      }
    }

    function stop() {
      signals.stop();
      const btn = document.getElementById('playBtn');
      if (btn) {
        btn.textContent = '‚ñ∂ Play';
        btn.classList.remove('playing');
      }
      cancelAnimationFrame(animationFrame);
      playheadTime = 0;
      updatePlayhead();
    }

    function updateLoop() {
      if (!signals.isPlaying()) return;
      playheadTime = signals.getCurrentTime();
      updatePlayhead();
      updateTrackValues();
      animationFrame = requestAnimationFrame(updateLoop);
    }

    function updatePlayhead() {
      const playhead = document.getElementById('playhead');
      const timeDisplay = document.getElementById('currentTime');
      if (!currentSong) return;
      
      const pct = (playheadTime / currentSong.duration) * 100;
      if (playhead) playhead.style.left = pct + '%';
      if (timeDisplay) timeDisplay.textContent = formatTimeMs(playheadTime);
    }

    function updateTrackValues() {
      if (!currentSong) return;
      
      currentSong.signalTracks.forEach((track, idx) => {
        const valueEl = document.getElementById(`trackValue${idx}`);
        const barEl = document.getElementById(`valueBar${idx}`);
        if (!valueEl) return;
        
        let value = 0;
        if (track.type === 'beat') {
          const beats = currentSong.beats[track.subtype] || [];
          // Check if there's a recent beat
          for (const bt of beats) {
            if (bt <= playheadTime && bt > playheadTime - track.decay) {
              const elapsed = playheadTime - bt;
              value = Math.max(value, 1 - (elapsed / track.decay));
            }
          }
        } else if (track.type === 'frequency') {
          value = getFrequencyValue(track, playheadTime);
          
          // Apply gain
          const gain = track.gain || 1;
          value = Math.min(1, value * gain);
          
          // Apply smoothing
          const smoothing = track.smoothing || 0;
          if (smoothing > 0) {
            const prevValue = track._smoothedValue || 0;
            value = prevValue + (value - prevValue) * (1 - smoothing);
            track._smoothedValue = value;
          }
        } else if (track.type === 'automation' && track.points) {
          value = interpolateAutomation(track.points, playheadTime);
        } else if (track.type === 'trigger' && track.triggers) {
          for (const t of track.triggers) {
            if (t.time <= playheadTime && t.time > playheadTime - track.decay) {
              const elapsed = playheadTime - t.time;
              value = Math.max(value, t.velocity * (1 - elapsed / track.decay));
            }
          }
        }
        
        // Update value display
        valueEl.textContent = value.toFixed(2);
        
        // Update value bar - fills from left to right
        if (barEl) {
          barEl.style.width = (value * 100) + '%';
          barEl.style.opacity = 0.2 + value * 0.4; // More opaque when higher
        }
      });
    }

    // Get frequency value with custom Hz range support
    function getFrequencyValue(track, time) {
      if (!currentSong?.frequency) return 0;
      
      const freqIdx = Math.floor(time * currentSong.frequency.sampleRate);
      const bandRanges = { sub: [20, 60], bass: [60, 250], mid: [250, 2000], high: [2000, 20000] };
      
      // For preset bands, use the pre-computed data
      if (track.subtype !== 'custom' && currentSong.frequency[track.subtype]) {
        const freq = currentSong.frequency[track.subtype];
        return freq[Math.min(freqIdx, freq.length - 1)] || 0;
      }
      
      // For custom ranges, blend between the bands based on Hz overlap
      const minHz = track.minHz || 20;
      const maxHz = track.maxHz || 20000;
      
      let totalWeight = 0;
      let weightedSum = 0;
      
      for (const [bandName, [bandMin, bandMax]] of Object.entries(bandRanges)) {
        const freq = currentSong.frequency[bandName];
        if (!freq) continue;
        
        // Calculate overlap between custom range and this band
        const overlapMin = Math.max(minHz, bandMin);
        const overlapMax = Math.min(maxHz, bandMax);
        
        if (overlapMin < overlapMax) {
          // Weight by the overlap width (log scale for perceptual accuracy)
          const overlapWeight = Math.log(overlapMax / overlapMin);
          const bandValue = freq[Math.min(freqIdx, freq.length - 1)] || 0;
          
          weightedSum += bandValue * overlapWeight;
          totalWeight += overlapWeight;
        }
      }
      
      return totalWeight > 0 ? weightedSum / totalWeight : 0;
    }

    function interpolateAutomation(points, time) {
      if (!points.length) return 0;
      if (time <= points[0][0]) return points[0][1];
      if (time >= points[points.length - 1][0]) return points[points.length - 1][1];
      
      for (let i = 0; i < points.length - 1; i++) {
        if (time >= points[i][0] && time < points[i + 1][0]) {
          const [t0, v0] = points[i];
          const [t1, v1] = points[i + 1];
          const t = (time - t0) / (t1 - t0);
          return v0 + (v1 - v0) * t * t * (3 - 2 * t); // Smooth step
        }
      }
      return 0;
    }

    // Drawing
    function drawWaveform() {
      const canvas = document.getElementById('waveformCanvas');
      if (!canvas || !waveformData) return;
      
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.offsetWidth * dpr;
      canvas.height = canvas.offsetHeight * dpr;
      ctx.scale(dpr, dpr);
      
      const w = canvas.offsetWidth;
      const h = canvas.offsetHeight;
      const centerY = h / 2;
      
      ctx.fillStyle = '#0a0a0b';
      ctx.fillRect(0, 0, w, h);
      
      const numPoints = waveformData.length / 2;
      const step = w / numPoints;
      
      ctx.fillStyle = 'rgba(0, 212, 255, 0.5)';
      for (let i = 0; i < numPoints; i++) {
        const min = waveformData[i * 2];
        const max = waveformData[i * 2 + 1];
        ctx.fillRect(i * step, centerY + min * centerY, Math.max(1, step - 0.5), (max - min) * centerY);
      }
    }

    function drawAllTracks() {
      if (!currentSong) return;
      currentSong.signalTracks.forEach((_, idx) => drawTrack(idx));
    }

    function drawTrack(index) {
      const canvas = document.getElementById(`trackCanvas${index}`);
      if (!canvas || !currentSong) return;
      
      const track = currentSong.signalTracks[index];
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.offsetWidth * dpr;
      canvas.height = canvas.offsetHeight * dpr;
      ctx.scale(dpr, dpr);
      
      const w = canvas.offsetWidth;
      const h = canvas.offsetHeight;
      
      ctx.fillStyle = '#08080a';
      ctx.fillRect(0, 0, w, h);
      
      // Grid lines
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      for (let i = 1; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(0, (i / 4) * h);
        ctx.lineTo(w, (i / 4) * h);
        ctx.stroke();
      }
      
      const color = TRACK_CONFIGS[track.type]?.color || '#666';
      
      if (track.type === 'beat') {
        const beats = currentSong.beats[track.subtype] || [];
        ctx.fillStyle = color;
        beats.forEach(time => {
          const x = (time / currentSong.duration) * w;
          ctx.fillRect(x - 1, 4, 2, h - 8);
        });
      } else if (track.type === 'frequency') {
        // Get the data to visualize (either preset band or compute from custom range)
        const numSamples = currentSong.frequency.sub?.length || 0;
        if (numSamples > 0) {
          ctx.fillStyle = color + '99';
          const step = w / numSamples;
          const gain = track.gain || 1;
          
          for (let i = 0; i < numSamples; i++) {
            // Compute value at this sample index
            const sampleTime = i / currentSong.frequency.sampleRate;
            let val = 0;
            
            if (track.subtype !== 'custom' && currentSong.frequency[track.subtype]) {
              val = currentSong.frequency[track.subtype][i] || 0;
            } else {
              // Custom range - blend bands
              const bandRanges = { sub: [20, 60], bass: [60, 250], mid: [250, 2000], high: [2000, 20000] };
              const minHz = track.minHz || 20;
              const maxHz = track.maxHz || 20000;
              let totalWeight = 0, weightedSum = 0;
              
              for (const [bandName, [bandMin, bandMax]] of Object.entries(bandRanges)) {
                const freq = currentSong.frequency[bandName];
                if (!freq) continue;
                const overlapMin = Math.max(minHz, bandMin);
                const overlapMax = Math.min(maxHz, bandMax);
                if (overlapMin < overlapMax) {
                  const overlapWeight = Math.log(overlapMax / overlapMin);
                  weightedSum += (freq[i] || 0) * overlapWeight;
                  totalWeight += overlapWeight;
                }
              }
              val = totalWeight > 0 ? weightedSum / totalWeight : 0;
            }
            
            val = Math.min(1, val * gain);
            ctx.fillRect(i * step, h - val * (h - 8), Math.max(1, step - 0.5), val * (h - 8));
          }
        }
      } else if (track.type === 'automation' && track.points) {
        // Draw curve
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        track.points.forEach(([t, v], i) => {
          const x = (t / currentSong.duration) * w;
          const y = (1 - v) * h;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        
        // Draw points
        track.points.forEach(([t, v]) => {
          const x = (t / currentSong.duration) * w;
          const y = (1 - v) * h;
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        });
      } else if (track.type === 'trigger' && track.triggers) {
        ctx.fillStyle = color;
        track.triggers.forEach(({ time, velocity }) => {
          const x = (time / currentSong.duration) * w;
          const barH = velocity * (h - 8);
          ctx.fillRect(x - 3, h - 4 - barH, 6, barH);
        });
      }
    }

    // Export
    function exportSong() {
      const data = buildExportData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = currentSong.name.replace(/[^a-z0-9]/gi, '-').toLowerCase() + '.json';
      a.click();
    }

    async function copySong() {
      const data = buildExportData();
      await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
      const btn = document.getElementById('copyBtn');
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 1500);
    }

    function buildExportData() {
      // Build signals object from tracks
      const signals = {};
      currentSong.signalTracks.forEach(track => {
        const signalName = track.name.replace(/\s+/g, '_').toLowerCase();
        signals[signalName] = {
          type: track.type,
          subtype: track.subtype,
          attack: track.attack,
          decay: track.decay,
          points: track.points,
          triggers: track.triggers
        };
      });
      
      // Get audio path from input or use default
      const audioPathInput = document.getElementById('audioPathInput');
      const audioPath = audioPathInput?.value || currentSong.audioPath || null;
      
      return {
        name: currentSong.name,
        duration: currentSong.duration,
        bpm: currentSong.bpm,
        audioUrl: audioPath, // Include the audio URL for sketches to load
        beats: currentSong.beats,
        frequency: currentSong.frequency,
        energy: currentSong.energy,
        signals
      };
    }

    async function deleteSong() {
      if (!confirm(`Delete "${currentSong.name}"?`)) return;
      const songId = currentSong.id;
      songs = songs.filter(s => s.id !== songId);
      currentSong = null;
      await deleteSongFromDB(songId);
      renderSongList();
      timelineEditor.innerHTML = '<div class="timeline-placeholder">Select or import a song to begin</div>';
    }

    // Storage - uses IndexedDB for full song data including audio
    async function saveSong(song) {
      try {
        await storeSongInDB(song);
      } catch (e) {
        console.error('Save error:', e);
      }
    }

    async function loadSongsFromDB() {
      try {
        // First try to load from IndexedDB
        const dbSongs = await loadAllSongsFromDB();
        if (dbSongs.length > 0) {
          songs = dbSongs;
          console.log(`Loaded ${songs.length} songs from IndexedDB`);
          return;
        }
        
        // Migration: try to load from localStorage and migrate
        const saved = localStorage.getItem('audioSongs');
        if (saved) {
          const legacySongs = JSON.parse(saved);
          console.log(`Migrating ${legacySongs.length} songs from localStorage to IndexedDB...`);
          
          for (const s of legacySongs) {
            // Try to get audio from file handle if available
            if (s.hasFileHandle) {
              const handle = await getFileHandle(s.id);
              if (handle) {
                try {
                  const file = await getFileFromHandle(handle);
                  if (file) {
                    const ab = await file.arrayBuffer();
                    s.audioData = ab;
                    console.log(`  Migrated audio for: ${s.name}`);
                  }
                } catch (e) {
                  console.warn(`  Could not migrate audio for ${s.name}:`, e);
                }
              }
            }
            await storeSongInDB(s);
          }
          
          songs = await loadAllSongsFromDB();
          // Clear localStorage after successful migration
          localStorage.removeItem('audioSongs');
          console.log('Migration complete!');
        }
      } catch (e) {
        console.error('Load error:', e);
        songs = [];
      }
    }

    // Legacy function name for compatibility - now saves individual song
    function saveSongsToStorage() {
      if (currentSong) {
        saveSong(currentSong);
      }
    }

    // Utility
    function formatTime(s) {
      const m = Math.floor(s / 60);
      const sec = Math.floor(s % 60);
      return `${m}:${sec.toString().padStart(2, '0')}`;
    }

    function formatTimeMs(s) {
      const m = Math.floor(s / 60);
      const sec = Math.floor(s % 60);
      const ms = Math.floor((s % 1) * 10);
      return `${m}:${sec.toString().padStart(2, '0')}.${ms}`;
    }

    // Window resize
    window.addEventListener('resize', () => {
      if (currentSong) {
        drawWaveform();
        drawAllTracks();
      }
    });

    // Context Menu for track binding
    let activeContextMenu = null;

    function showContextMenu(x, y, trackIndex) {
      hideContextMenu();
      
      const track = currentSong.signalTracks[trackIndex];
      const signalName = track.name.replace(/\s+/g, '_').toLowerCase();
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div class="context-menu-item" data-action="copy-name">
          Copy Signal Name
          <span class="shortcut">${signalName}</span>
        </div>
        <div class="context-menu-item" data-action="copy-code">
          Copy Usage Code
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="copy-value-code">
          Copy Value Expression
        </div>
      `;
      
      // Position menu
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      document.body.appendChild(menu);
      
      // Adjust if off-screen
      const rect = menu.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        menu.style.left = (x - rect.width) + 'px';
      }
      if (rect.bottom > window.innerHeight) {
        menu.style.top = (y - rect.height) + 'px';
      }
      
      // Handle clicks
      menu.addEventListener('click', async (e) => {
        const item = e.target.closest('.context-menu-item');
        if (!item) return;
        
        const action = item.dataset.action;
        
        if (action === 'copy-name') {
          await navigator.clipboard.writeText(signalName);
          showToast(`Copied: ${signalName}`);
        } else if (action === 'copy-code') {
          const code = generateTrackCode(track);
          await navigator.clipboard.writeText(code);
          showToast('Copied usage code');
        } else if (action === 'copy-value-code') {
          const code = generateValueExpression(track);
          await navigator.clipboard.writeText(code);
          showToast('Copied value expression');
        }
        
        hideContextMenu();
      });
      
      activeContextMenu = menu;
    }

    function hideContextMenu() {
      if (activeContextMenu) {
        activeContextMenu.remove();
        activeContextMenu = null;
      }
    }

    function generateTrackCode(track) {
      const signalName = track.name.replace(/\s+/g, '_').toLowerCase();
      
      if (track.type === 'beat') {
        return `// ${track.name} - Beat detection
const ${signalName} = (() => {
  const beats = trackData.beats.${track.subtype} || [];
  const decay = ${track.decay};
  let value = 0;
  for (const bt of beats) {
    if (bt <= time && bt > time - decay) {
      value = Math.max(value, 1 - (time - bt) / decay);
    }
  }
  return value;
})();`;
      } else if (track.type === 'frequency') {
        return `// ${track.name} - Frequency band
const ${signalName} = (() => {
  const freq = trackData.frequency.${track.subtype};
  const idx = Math.floor(time * trackData.frequency.sampleRate);
  return (freq?.[Math.min(idx, freq.length - 1)] || 0) * ${track.gain || 1};
})();`;
      } else if (track.type === 'automation') {
        return `// ${track.name} - Automation curve
const ${signalName} = signals.${signalName}; // From exported track data`;
      } else if (track.type === 'trigger') {
        return `// ${track.name} - Trigger events
const ${signalName} = (() => {
  const triggers = signals.${signalName}?.triggers || [];
  const decay = ${track.decay};
  let value = 0;
  for (const t of triggers) {
    if (t.time <= time && t.time > time - decay) {
      value = Math.max(value, t.velocity * (1 - (time - t.time) / decay));
    }
  }
  return value;
})();`;
      }
      return `const ${signalName} = 0; // Unknown track type`;
    }

    function generateValueExpression(track) {
      const signalName = track.name.replace(/\s+/g, '_').toLowerCase();
      
      if (track.type === 'beat') {
        return `getBeatValue(trackData.beats.${track.subtype}, time, ${track.decay})`;
      } else if (track.type === 'frequency') {
        return `getFrequency('${track.subtype}', time) * ${track.gain || 1}`;
      } else if (track.type === 'automation') {
        return `getAutomation('${signalName}', time)`;
      } else if (track.type === 'trigger') {
        return `getTriggerValue('${signalName}', time, ${track.decay})`;
      }
      return '0';
    }

    function showToast(message) {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #1a1a1e;
        border: 1px solid #ff6b35;
        color: #e8e8e8;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 0.7rem;
        font-family: 'JetBrains Mono', monospace;
        z-index: 3000;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 2000);
    }

    // Global click to close context menu
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.context-menu')) {
        hideContextMenu();
      }
    });

    document.addEventListener('contextmenu', (e) => {
      // Only prevent default if clicking on a track
      if (e.target.closest('.signal-track')) {
        e.preventDefault();
      }
    });
  </script>
</body>
</html>
