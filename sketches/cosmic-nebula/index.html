<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosmic Nebula</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #000000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.005);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 40);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5, 0.4, 0.3
    );
    composer.addPass(bloomPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.minDistance = 20;
    controls.maxDistance = 80;

    // Create starfield
    function createStarfield() {
      const count = 5000;
      const positions = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const phases = new Float32Array(count);
      
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 60 + Math.random() * 40;
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
        sizes[i] = 0.5 + Math.random() * 1.5;
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
          attribute float size;
          attribute float phase;
          varying float vAlpha;
          uniform float uTime;
          void main() {
            float twinkle = sin(uTime * 2.0 + phase * 5.0) * 0.5 + 0.5;
            vAlpha = 0.3 + twinkle * 0.7;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (200.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          void main() {
            float d = length(gl_PointCoord - 0.5);
            float a = 1.0 - smoothstep(0.0, 0.5, d);
            gl_FragColor = vec4(1.0, 1.0, 1.0, a * vAlpha * 0.8);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }
    const stars = createStarfield();
    scene.add(stars);

    // Create nebula clouds using volumetric particles
    function createNebulaCloud() {
      const count = 15000;
      const positions = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const phases = new Float32Array(count);
      const colorSeeds = new Float32Array(count);
      
      // Create cloud shape using noise-like distribution
      for (let i = 0; i < count; i++) {
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI * 2;
        const radius = 3 + Math.pow(Math.random(), 2) * 12;
        
        positions[i * 3] = Math.cos(angle1) * Math.cos(angle2) * radius;
        positions[i * 3 + 1] = Math.sin(angle1) * radius;
        positions[i * 3 + 2] = Math.cos(angle1) * Math.sin(angle2) * radius;
        
        sizes[i] = 0.8 + Math.random() * 1.5;
        phases[i] = Math.random() * Math.PI * 2;
        colorSeeds[i] = Math.random();
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
      geo.setAttribute('colorSeed', new THREE.BufferAttribute(colorSeeds, 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uCenter: { value: new THREE.Vector3(0, 0, 0) }
        },
        vertexShader: `
          attribute float size;
          attribute float phase;
          attribute float colorSeed;
          
          uniform float uTime;
          uniform vec3 uCenter;
          
          varying float vAlpha;
          varying float vColorSeed;
          varying float vDist;
          
          void main() {
            vec3 pos = position;
            
            // Slow swirling motion
            float angle = phase + uTime * 0.1;
            float radius = length(pos.xz);
            pos.x = cos(angle) * radius;
            pos.z = sin(angle) * radius;
            
            // Add vertical drift
            pos.y += sin(uTime * 0.05 + phase) * 0.5;
            
            // Distance from center affects alpha
            vDist = length(pos - uCenter) / 15.0;
            
            vColorSeed = colorSeed;
            vAlpha = 1.0;
            
            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (300.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform float uTime;
          
          varying float vAlpha;
          varying float vColorSeed;
          varying float vDist;
          
          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          
          void main() {
            float d = length(gl_PointCoord - 0.5);
            float a = 1.0 - smoothstep(0.0, 0.5, d);
            a += exp(-d * 4.0) * 0.5;
            
            // Nebula colors - purple, pink, blue
            float hue = 0.7 + vColorSeed * 0.3 + sin(uTime * 0.2 + vDist * 2.0) * 0.1;
            float sat = 0.6 + sin(uTime * 0.3 + vColorSeed * 5.0) * 0.3;
            float val = 0.7 + sin(uTime * 0.4 + vDist * 3.0) * 0.3;
            
            vec3 color = hsv2rgb(vec3(fract(hue), sat, val));
            
            // Fade at edges
            float distFade = 1.0 - smoothstep(0.5, 1.0, vDist);
            
            gl_FragColor = vec4(color, a * vAlpha * distFade * 0.4);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }

    // Create multiple nebula clouds
    const nebulas = [];
    const NUM_NEBULAS = 3;
    
    for (let i = 0; i < NUM_NEBULAS; i++) {
      const nebula = createNebulaCloud();
      const offsetX = (i - 1) * 8;
      const offsetY = Math.sin(i) * 5;
      const offsetZ = Math.cos(i) * 5;
      nebula.position.set(offsetX, offsetY, offsetZ);
      scene.add(nebula);
      nebulas.push(nebula);
    }

    // Animation
    function animate(time) {
      const t = time * 0.001;
      
      stars.material.uniforms.uTime.value = t;
      
      nebulas.forEach((nebula, i) => {
        nebula.material.uniforms.uTime.value = t;
        // Slow rotation
        nebula.rotation.y = t * 0.05 + i * 0.5;
        nebula.rotation.x = Math.sin(t * 0.03 + i) * 0.2;
      });
      
      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    
    animate(0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
