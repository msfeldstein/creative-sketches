<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aurora Veil</title>
  <style>
    * { margin: 0; padding: 0; }
    body {
      overflow: hidden;
      background: #020308;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas { display: block; }
    .hint {
      position: fixed;
      left: 18px;
      bottom: 16px;
      color: rgba(255, 255, 255, 0.35);
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="hint">Drag to orbit | Scroll to zoom</div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020308, 0.035);

    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      220
    );
    camera.position.set(0, 9, 28);
    camera.lookAt(0, 7, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x020308);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 7, 0);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.25;
    controls.minDistance = 12;
    controls.maxDistance = 65;

    function createStarfield() {
      const count = 2500;
      const positions = new Float32Array(count * 3);
      const phases = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 60 + Math.random() * 90;
        positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
        positions[i * 3 + 1] = Math.cos(phi) * radius * 0.6 + 12;
        positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * radius;
        phases[i] = Math.random() * Math.PI * 2;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("phase", new THREE.BufferAttribute(phases, 1));

      const material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
          attribute float phase;
          uniform float uTime;
          varying float vAlpha;
          void main() {
            float twinkle = sin(uTime * 0.8 + phase * 6.283) * 0.5 + 0.5;
            vAlpha = 0.2 + twinkle * 0.7;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = (1.2 + twinkle * 1.8) * (220.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          void main() {
            float d = length(gl_PointCoord - 0.5);
            float a = smoothstep(0.5, 0.0, d);
            vec3 color = vec3(0.7, 0.85, 1.0);
            gl_FragColor = vec4(color, a * vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const points = new THREE.Points(geometry, material);
      points.userData.material = material;
      return points;
    }

    function createCurtainGeometry() {
      const cols = 160;
      const rows = 120;
      const width = 46;
      const height = 28;
      const count = cols * rows;

      const positions = new Float32Array(count * 3);
      const phases = new Float32Array(count);
      const columns = new Float32Array(count);
      const rowsAttr = new Float32Array(count);

      let ptr = 0;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const col = x / (cols - 1);
          const row = y / (rows - 1);
          positions[ptr * 3] = (col - 0.5) * width;
          positions[ptr * 3 + 1] = row * height;
          positions[ptr * 3 + 2] = 0;
          phases[ptr] = Math.random() * Math.PI * 2;
          columns[ptr] = col;
          rowsAttr[ptr] = row;
          ptr++;
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("aPhase", new THREE.BufferAttribute(phases, 1));
      geometry.setAttribute("aColumn", new THREE.BufferAttribute(columns, 1));
      geometry.setAttribute("aRow", new THREE.BufferAttribute(rowsAttr, 1));
      return geometry;
    }

    const starfield = createStarfield();
    scene.add(starfield);

    const curtainGeometry = createCurtainGeometry();
    const curtainGroup = new THREE.Group();
    const curtainMaterials = [];

    const curtainCount = 5;
    const curtainSpacing = 6.5;
    const baseColorA = new THREE.Color(0x00e5b0);
    const baseColorB = new THREE.Color(0x64d6ff);
    const baseColorC = new THREE.Color(0xffd27a);

    for (let i = 0; i < curtainCount; i++) {
      const shift = (i - (curtainCount - 1) / 2) * 0.05;
      const colorA = baseColorA.clone().offsetHSL(shift, 0, 0);
      const colorB = baseColorB.clone().offsetHSL(shift * 0.8, 0, 0);
      const colorC = baseColorC.clone().offsetHSL(-shift * 0.5, -0.1, 0);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColorA: { value: colorA },
          uColorB: { value: colorB },
          uColorC: { value: colorC },
          uIntensity: { value: 0.8 + Math.random() * 0.35 },
          uWaveAmp: { value: 1.2 + Math.random() * 0.9 },
          uXOffset: { value: (Math.random() - 0.5) * 6 },
          uZOffset: { value: (i - (curtainCount - 1) / 2) * curtainSpacing },
          uPointSize: { value: 1.4 + Math.random() * 0.8 }
        },
        vertexShader: `
          attribute float aPhase;
          attribute float aColumn;
          attribute float aRow;

          uniform float uTime;
          uniform float uWaveAmp;
          uniform float uXOffset;
          uniform float uZOffset;
          uniform float uPointSize;

          varying float vAlpha;
          varying float vHeight;
          varying float vGlow;

          void main() {
            float heightFactor = aRow;
            float widthFactor = 1.0 - abs(aColumn - 0.5) * 2.0;
            widthFactor = smoothstep(0.0, 1.0, widthFactor);

            float wave = sin(heightFactor * 12.0 + uTime * 0.7 + aPhase * 2.0);
            float wave2 = sin(heightFactor * 4.0 + uTime * 0.4 + aPhase * 3.0);
            float ripple = sin(aColumn * 14.0 + uTime * 0.8 + aPhase);

            vec3 pos = position;
            pos.x += (wave * 0.7 + wave2 * 0.3) * uWaveAmp * widthFactor;
            pos.x += ripple * 0.6 * widthFactor;
            pos.z += cos(heightFactor * 10.0 + uTime * 0.6 + aPhase) * uWaveAmp * 0.6;

            pos.x += uXOffset;
            pos.z += uZOffset;

            float pulse = sin(uTime * 1.1 + aPhase * 4.0 + heightFactor * 6.0) * 0.5 + 0.5;
            vAlpha = smoothstep(0.0, 0.08, heightFactor) * (0.35 + pulse * 0.65) * widthFactor;
            vHeight = heightFactor;
            vGlow = widthFactor;

            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = uPointSize
              * (0.7 + widthFactor * 0.9)
              * (1.1 - heightFactor * 0.5)
              * (220.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform vec3 uColorA;
          uniform vec3 uColorB;
          uniform vec3 uColorC;
          uniform float uIntensity;

          varying float vAlpha;
          varying float vHeight;
          varying float vGlow;

          void main() {
            float d = length(gl_PointCoord - 0.5);
            float mask = smoothstep(0.5, 0.0, d);
            vec3 color = mix(uColorA, uColorB, smoothstep(0.0, 0.6, vHeight));
            color = mix(color, uColorC, smoothstep(0.55, 1.0, vHeight));
            color *= 0.7 + vGlow * 0.6;
            float alpha = mask * vAlpha * uIntensity;
            if (alpha < 0.01) discard;
            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const curtain = new THREE.Points(curtainGeometry, material);
      curtain.frustumCulled = false;
      curtainGroup.add(curtain);
      curtainMaterials.push(material);
    }

    curtainGroup.rotation.y = 0.2;
    scene.add(curtainGroup);

    function createMotes() {
      const count = 900;
      const positions = new Float32Array(count * 3);
      const phases = new Float32Array(count);
      const speeds = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = Math.random() * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
        phases[i] = Math.random() * Math.PI * 2;
        speeds[i] = 0.4 + Math.random() * 0.6;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("phase", new THREE.BufferAttribute(phases, 1));
      geometry.setAttribute("speed", new THREE.BufferAttribute(speeds, 1));

      const material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
          attribute float phase;
          attribute float speed;
          uniform float uTime;
          varying float vAlpha;
          void main() {
            float t = uTime * speed + phase;
            vec3 pos = position;
            pos.y = mod(position.y + t * 2.0, 22.0) - 4.0;
            pos.x += sin(t * 0.6 + position.z * 0.05) * 0.6;
            pos.z += cos(t * 0.5 + position.x * 0.05) * 0.6;
            float flicker = sin(t * 1.4 + phase) * 0.5 + 0.5;
            vAlpha = 0.2 + flicker * 0.6;
            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = (0.9 + flicker * 0.6) * (160.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          void main() {
            float d = length(gl_PointCoord - 0.5);
            float a = smoothstep(0.5, 0.0, d);
            vec3 color = vec3(0.65, 0.85, 1.0);
            gl_FragColor = vec4(color, a * vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const points = new THREE.Points(geometry, material);
      points.userData.material = material;
      return points;
    }

    const motes = createMotes();
    scene.add(motes);

    const groundGeo = new THREE.CircleGeometry(80, 64);
    const groundMat = new THREE.MeshBasicMaterial({
      color: 0x05060f,
      transparent: true,
      opacity: 0.35,
      depthWrite: false
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1.5;
    scene.add(ground);

    function animate(time) {
      const t = time * 0.001;
      starfield.userData.material.uniforms.uTime.value = t;
      motes.userData.material.uniforms.uTime.value = t;
      curtainMaterials.forEach((material) => {
        material.uniforms.uTime.value = t;
      });

      curtainGroup.rotation.y = 0.2 + Math.sin(t * 0.05) * 0.08;
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate(0);

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>
</html>
