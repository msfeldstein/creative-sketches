<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometric Rain</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #0a0a12; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a12, 0.015);
    
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 20);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x0a0a12);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.body.appendChild(renderer.domElement);

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8, 0.3, 0.4
    );
    composer.addPass(bloomPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;

    // Reflective ground plane
    function createGround() {
      const geo = new THREE.PlaneGeometry(100, 100, 100, 100);
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 }
        },
        vertexShader: `
          uniform float uTime;
          varying vec2 vUv;
          varying vec3 vWorldPos;
          
          void main() {
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            
            // Ripple effect
            float dist = length(worldPos.xz);
            worldPos.y += sin(dist * 0.5 - uTime * 2.0) * 0.1 * exp(-dist * 0.05);
            
            vWorldPos = worldPos.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          uniform float uTime;
          varying vec2 vUv;
          varying vec3 vWorldPos;
          
          float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
          
          void main() {
            vec2 gridUv = vWorldPos.xz;
            
            // Grid pattern
            vec2 grid = abs(fract(gridUv * 0.5) - 0.5);
            float gridLine = min(grid.x, grid.y);
            gridLine = smoothstep(0.0, 0.02, gridLine);
            
            // Base reflection color
            vec3 baseColor = vec3(0.02, 0.03, 0.06);
            vec3 gridColor = vec3(0.1, 0.15, 0.25);
            
            vec3 color = mix(gridColor, baseColor, gridLine);
            
            // Ripple highlights
            float dist = length(vWorldPos.xz);
            float ripple = sin(dist * 0.8 - uTime * 3.0) * 0.5 + 0.5;
            ripple *= exp(-dist * 0.03);
            
            color += vec3(0.1, 0.2, 0.4) * ripple * 0.3;
            
            // Distance fade
            float fade = 1.0 - smoothstep(20.0, 50.0, dist);
            
            gl_FragColor = vec4(color, fade * 0.9);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.y = -5;
      return mesh;
    }
    const ground = createGround();
    scene.add(ground);

    // Create different geometric shapes
    const SHAPE_TYPES = ['tetrahedron', 'octahedron', 'icosahedron', 'cube', 'ring'];
    
    function createShapeGeometry(type) {
      switch(type) {
        case 'tetrahedron': return new THREE.TetrahedronGeometry(0.5);
        case 'octahedron': return new THREE.OctahedronGeometry(0.4);
        case 'icosahedron': return new THREE.IcosahedronGeometry(0.35);
        case 'cube': return new THREE.BoxGeometry(0.5, 0.5, 0.5);
        case 'ring': return new THREE.TorusGeometry(0.3, 0.1, 8, 16);
        default: return new THREE.OctahedronGeometry(0.4);
      }
    }

    // Falling shapes
    const NUM_SHAPES = 200;
    const shapes = [];
    
    for (let i = 0; i < NUM_SHAPES; i++) {
      const type = SHAPE_TYPES[Math.floor(Math.random() * SHAPE_TYPES.length)];
      const geo = createShapeGeometry(type);
      
      const hue = 0.55 + Math.random() * 0.25; // Cyan to purple range
      const sat = 0.6 + Math.random() * 0.3;
      const lightness = 0.4 + Math.random() * 0.3;
      
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uHue: { value: hue },
          uSat: { value: sat },
          uLightness: { value: lightness }
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vNormal = normalMatrix * normal;
            vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float uTime;
          uniform float uHue;
          uniform float uSat;
          uniform float uLightness;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          
          void main() {
            vec3 viewDir = normalize(-vPosition);
            float fresnel = pow(1.0 - max(dot(normalize(vNormal), viewDir), 0.0), 2.0);
            
            // Edge glow effect
            vec3 baseColor = hsv2rgb(vec3(uHue, uSat, uLightness));
            vec3 glowColor = hsv2rgb(vec3(uHue + 0.05, uSat * 0.8, 1.0));
            
            vec3 color = mix(baseColor, glowColor, fresnel);
            
            // Inner shimmer
            float shimmer = sin(uTime * 3.0 + vPosition.x * 10.0 + vPosition.y * 10.0) * 0.5 + 0.5;
            color += glowColor * shimmer * 0.2;
            
            float alpha = 0.7 + fresnel * 0.3;
            
            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      
      const mesh = new THREE.Mesh(geo, mat);
      
      // Random starting position
      mesh.position.set(
        (Math.random() - 0.5) * 40,
        Math.random() * 40 + 10,
        (Math.random() - 0.5) * 40
      );
      
      const scale = 0.5 + Math.random() * 1.5;
      mesh.scale.setScalar(scale);
      
      shapes.push({
        mesh,
        type,
        fallSpeed: 2 + Math.random() * 4,
        rotationSpeed: new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        ),
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 1 + Math.random() * 2,
        wobbleAmount: 0.5 + Math.random() * 1
      });
      
      scene.add(mesh);
    }

    // Vertical light beams
    function createLightBeams() {
      const NUM_BEAMS = 20;
      const beams = [];
      
      for (let i = 0; i < NUM_BEAMS; i++) {
        const height = 30;
        const geo = new THREE.CylinderGeometry(0.05, 0.2, height, 8, 1, true);
        
        const hue = 0.5 + Math.random() * 0.3;
        
        const mat = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uHue: { value: hue }
          },
          vertexShader: `
            varying vec2 vUv;
            varying float vY;
            
            void main() {
              vUv = uv;
              vY = position.y;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform float uHue;
            varying vec2 vUv;
            varying float vY;
            
            vec3 hsv2rgb(vec3 c) {
              vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
              vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
              return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            void main() {
              float heightFade = smoothstep(-15.0, 0.0, vY) * smoothstep(15.0, 5.0, vY);
              
              // Animated pulse
              float pulse = sin(vY * 0.5 - uTime * 5.0) * 0.5 + 0.5;
              
              vec3 color = hsv2rgb(vec3(uHue, 0.7, 0.9));
              
              float alpha = heightFade * 0.15 * (0.5 + pulse * 0.5);
              
              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(
          (Math.random() - 0.5) * 50,
          5,
          (Math.random() - 0.5) * 50
        );
        
        beams.push({ mesh, material: mat });
        scene.add(mesh);
      }
      
      return beams;
    }
    const lightBeams = createLightBeams();

    // Rain particle trails
    function createRainTrails() {
      const count = 5000;
      const positions = new Float32Array(count * 3);
      const speeds = new Float32Array(count);
      const phases = new Float32Array(count);
      
      for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 60;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
        speeds[i] = 5 + Math.random() * 10;
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
          attribute float speed;
          attribute float phase;
          uniform float uTime;
          varying float vAlpha;
          
          void main() {
            vec3 pos = position;
            pos.y = mod(pos.y - uTime * speed, 50.0);
            
            float heightFade = smoothstep(0.0, 5.0, pos.y) * smoothstep(50.0, 40.0, pos.y);
            vAlpha = heightFade * 0.6;
            
            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = 2.0 * (50.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          
          void main() {
            vec2 center = gl_PointCoord - 0.5;
            float d = length(center);
            
            // Elongate vertically for rain effect
            float rain = smoothstep(0.5, 0.0, abs(center.x) * 3.0) * 
                        smoothstep(0.5, 0.0, abs(center.y) * 1.0);
            
            vec3 color = vec3(0.5, 0.7, 1.0);
            
            gl_FragColor = vec4(color, rain * vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }
    const rainTrails = createRainTrails();
    scene.add(rainTrails);

    // Splash particles at ground level
    const splashes = [];
    const MAX_SPLASHES = 50;
    
    function createSplash(x, z) {
      const count = 20;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 1.5;
        positions[i * 3] = x;
        positions[i * 3 + 1] = -5;
        positions[i * 3 + 2] = z;
        velocities.push({
          x: Math.cos(angle) * speed,
          y: 2 + Math.random() * 3,
          z: Math.sin(angle) * speed
        });
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const mat = new THREE.PointsMaterial({
        size: 0.1,
        color: 0x88aaff,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const points = new THREE.Points(geo, mat);
      scene.add(points);
      
      return {
        mesh: points,
        velocities,
        age: 0,
        maxAge: 1.5
      };
    }

    // Animation
    let lastSplashTime = 0;
    
    function animate(time) {
      const t = time * 0.001;
      const dt = 0.016;
      
      // Update shapes
      shapes.forEach(shape => {
        // Fall
        shape.mesh.position.y -= shape.fallSpeed * dt;
        
        // Wobble horizontally
        shape.wobble += shape.wobbleSpeed * dt;
        shape.mesh.position.x += Math.sin(shape.wobble) * shape.wobbleAmount * dt;
        shape.mesh.position.z += Math.cos(shape.wobble * 0.7) * shape.wobbleAmount * 0.5 * dt;
        
        // Rotate
        shape.mesh.rotation.x += shape.rotationSpeed.x * dt;
        shape.mesh.rotation.y += shape.rotationSpeed.y * dt;
        shape.mesh.rotation.z += shape.rotationSpeed.z * dt;
        
        // Reset when below ground
        if (shape.mesh.position.y < -5) {
          // Create splash
          if (splashes.length < MAX_SPLASHES && t - lastSplashTime > 0.05) {
            splashes.push(createSplash(shape.mesh.position.x, shape.mesh.position.z));
            lastSplashTime = t;
          }
          
          // Reset position
          shape.mesh.position.y = 30 + Math.random() * 20;
          shape.mesh.position.x = (Math.random() - 0.5) * 40;
          shape.mesh.position.z = (Math.random() - 0.5) * 40;
        }
        
        shape.mesh.material.uniforms.uTime.value = t;
      });
      
      // Update splashes
      for (let i = splashes.length - 1; i >= 0; i--) {
        const splash = splashes[i];
        splash.age += dt;
        
        if (splash.age > splash.maxAge) {
          scene.remove(splash.mesh);
          splash.mesh.geometry.dispose();
          splash.mesh.material.dispose();
          splashes.splice(i, 1);
          continue;
        }
        
        const positions = splash.mesh.geometry.getAttribute('position');
        const posArray = positions.array;
        
        for (let j = 0; j < splash.velocities.length; j++) {
          const vel = splash.velocities[j];
          
          posArray[j * 3] += vel.x * dt;
          posArray[j * 3 + 1] += vel.y * dt;
          posArray[j * 3 + 2] += vel.z * dt;
          
          vel.y -= 9.8 * dt; // Gravity
        }
        
        positions.needsUpdate = true;
        splash.mesh.material.opacity = 1 - (splash.age / splash.maxAge);
      }
      
      // Update other elements
      ground.material.uniforms.uTime.value = t;
      rainTrails.material.uniforms.uTime.value = t;
      
      lightBeams.forEach(beam => {
        beam.material.uniforms.uTime.value = t;
      });
      
      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    
    animate(0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
